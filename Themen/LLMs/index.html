
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../Face_Aging/">
      
      
        <link rel="next" href="../Spracherkennung/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.1, mkdocs-material-9.1.21">
    
    
      
        <title>Large Language Models - Seminar Aktuelle Themen der künstlichen Intelligenz</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.eebd395e.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
      <link rel="stylesheet" href="../../javascripts/mathjax.js">
    
      <link rel="stylesheet" href="https://polyfill.io/v3/polyfill.min.js?features=es6">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#large-language-models" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Seminar Aktuelle Themen der künstlichen Intelligenz" class="md-header__button md-logo" aria-label="Seminar Aktuelle Themen der künstlichen Intelligenz" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Seminar Aktuelle Themen der künstlichen Intelligenz
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Large Language Models
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Seminar Aktuelle Themen der künstlichen Intelligenz" class="md-nav__button md-logo" aria-label="Seminar Aktuelle Themen der künstlichen Intelligenz" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Seminar Aktuelle Themen der künstlichen Intelligenz
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Aktuelles
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          Themen
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Themen
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Einf%C3%A4rben%20von%20Bildern/" class="md-nav__link">
        Einfärben von Bildern - Zwei Ansätze
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Empfehlungssysteme/" class="md-nav__link">
        Empfehlungssysteme
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Face_Aging/" class="md-nav__link">
        Face Aging
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Large Language Models
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Large Language Models
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstract" class="md-nav__link">
    Abstract
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-einleitung-motivation" class="md-nav__link">
    1 Einleitung / Motivation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-methoden" class="md-nav__link">
    2 Methoden
  </a>
  
    <nav class="md-nav" aria-label="2 Methoden">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-daten" class="md-nav__link">
    2.1 Daten
  </a>
  
    <nav class="md-nav" aria-label="2.1 Daten">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#211-tokenisierung" class="md-nav__link">
    2.1.1 Tokenisierung
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#212-subword-tokenization" class="md-nav__link">
    2.1.2 Subword Tokenization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#213-embeddings" class="md-nav__link">
    2.1.3 Embeddings
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-transformer" class="md-nav__link">
    2.2 Transformer
  </a>
  
    <nav class="md-nav" aria-label="2.2 Transformer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221-positional-encoding" class="md-nav__link">
    2.2.1 Positional Encoding
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222-architektur" class="md-nav__link">
    2.2.2 Architektur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223-self-attention" class="md-nav__link">
    2.2.3 Self-Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#224-cross-attention" class="md-nav__link">
    2.2.4 Cross-Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#225-masked-attention" class="md-nav__link">
    2.2.5 Masked Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#226-multi-head-attention" class="md-nav__link">
    2.2.6 Multi-Head Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#227-feed-forward-network" class="md-nav__link">
    2.2.7 Feed Forward Network
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#228-residual-connections" class="md-nav__link">
    2.2.8 Residual Connections
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#229-layer-normalization" class="md-nav__link">
    2.2.9 Layer Normalization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2210-dropout-optimizer" class="md-nav__link">
    2.2.10 Dropout &amp; Optimizer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2211-output-layer" class="md-nav__link">
    2.2.11 Output Layer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-bert" class="md-nav__link">
    2.3 BERT
  </a>
  
    <nav class="md-nav" aria-label="2.3 BERT">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#231-architektur" class="md-nav__link">
    2.3.1 Architektur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#232-masked-language-model" class="md-nav__link">
    2.3.2 Masked Language Model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#233-next-sentence-prediction" class="md-nav__link">
    2.3.3 Next Sentence Prediction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#234-pre-training" class="md-nav__link">
    2.3.4 Pre-Training
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#235-fine-tuning" class="md-nav__link">
    2.3.5 Fine-Tuning
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24-fine-tuning" class="md-nav__link">
    2.4 Fine-Tuning
  </a>
  
    <nav class="md-nav" aria-label="2.4 Fine-Tuning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#241-aufgaben" class="md-nav__link">
    2.4.1 Aufgaben
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#242-overfitting" class="md-nav__link">
    2.4.2 Overfitting
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25-generative-pre-training" class="md-nav__link">
    2.5 Generative Pre-Training
  </a>
  
    <nav class="md-nav" aria-label="2.5 Generative Pre-Training">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#251-architektur-pre-training" class="md-nav__link">
    2.5.1 Architektur / Pre-Training
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#252-fine-tuning" class="md-nav__link">
    2.5.2 Fine-Tuning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#253-reward-model" class="md-nav__link">
    2.5.3 Reward Model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#254-reinforcement-learning" class="md-nav__link">
    2.5.4 Reinforcement Learning
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26-meta-learning" class="md-nav__link">
    2.6 Meta-Learning
  </a>
  
    <nav class="md-nav" aria-label="2.6 Meta-Learning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#261-zero-shot-learning" class="md-nav__link">
    2.6.1 Zero-Shot Learning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#262-one-shot-learning" class="md-nav__link">
    2.6.2 One-Shot Learning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#263-few-shot-learning" class="md-nav__link">
    2.6.3 Few-Shot Learning
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#27-benchmarking" class="md-nav__link">
    2.7 Benchmarking
  </a>
  
    <nav class="md-nav" aria-label="2.7 Benchmarking">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#271-glue" class="md-nav__link">
    2.7.1 GLUE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#272-superglue" class="md-nav__link">
    2.7.2 SuperGLUE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#273-squad" class="md-nav__link">
    2.7.3 SQuAD
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#274-modelle" class="md-nav__link">
    2.7.4 Modelle
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-anwendungen" class="md-nav__link">
    3 Anwendungen
  </a>
  
    <nav class="md-nav" aria-label="3 Anwendungen">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-limitationen-heutiger-large-language-models" class="md-nav__link">
    3.1 Limitationen heutiger Large Language Models
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-die-losung-langchain" class="md-nav__link">
    3.2 Die Lösung: LangChain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-code-demo-der-allwissende-podcast-schreiber" class="md-nav__link">
    3.3 Code Demo: Der allwissende Podcast Schreiber
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-eine-neue-art-des-programmierens-prompt-engineering" class="md-nav__link">
    3.4 Eine Neue Art des Programmierens: Prompt Engineering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-open-source-alternativen" class="md-nav__link">
    3.5 Open Source Alternativen
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-fazit" class="md-nav__link">
    4 Fazit
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-weiterfuhrendes-material" class="md-nav__link">
    5 Weiterführendes Material
  </a>
  
    <nav class="md-nav" aria-label="5 Weiterführendes Material">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-podcast" class="md-nav__link">
    5.1 Podcast
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-talk" class="md-nav__link">
    5.2 Talk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-demo" class="md-nav__link">
    5.3 Demo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-literaturliste" class="md-nav__link">
    6 Literaturliste
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Spracherkennung/" class="md-nav__link">
        Spracherkennung
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../T09_Dialekte_Spracherkennung/" class="md-nav__link">
        T09 - Dialekte in der Spracherkennung
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../T12_feature-extraction/" class="md-nav__link">
        Feature Extraction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../TextToSpeech/" class="md-nav__link">
        Text-to-Speech
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Zeitserienanalyse/" class="md-nav__link">
        Zeitserienanalyse
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bayesian_modeling/" class="md-nav__link">
        Bayesian Modeling
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../t7_Process_Mining/" class="md-nav__link">
        Process Mining
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../transfer_learning_nlp/" class="md-nav__link">
        Transfer Learning in der Sprachverarbeitung
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../impressum/" class="md-nav__link">
        Impressum
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstract" class="md-nav__link">
    Abstract
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-einleitung-motivation" class="md-nav__link">
    1 Einleitung / Motivation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-methoden" class="md-nav__link">
    2 Methoden
  </a>
  
    <nav class="md-nav" aria-label="2 Methoden">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-daten" class="md-nav__link">
    2.1 Daten
  </a>
  
    <nav class="md-nav" aria-label="2.1 Daten">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#211-tokenisierung" class="md-nav__link">
    2.1.1 Tokenisierung
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#212-subword-tokenization" class="md-nav__link">
    2.1.2 Subword Tokenization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#213-embeddings" class="md-nav__link">
    2.1.3 Embeddings
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-transformer" class="md-nav__link">
    2.2 Transformer
  </a>
  
    <nav class="md-nav" aria-label="2.2 Transformer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#221-positional-encoding" class="md-nav__link">
    2.2.1 Positional Encoding
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#222-architektur" class="md-nav__link">
    2.2.2 Architektur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#223-self-attention" class="md-nav__link">
    2.2.3 Self-Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#224-cross-attention" class="md-nav__link">
    2.2.4 Cross-Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#225-masked-attention" class="md-nav__link">
    2.2.5 Masked Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#226-multi-head-attention" class="md-nav__link">
    2.2.6 Multi-Head Attention
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#227-feed-forward-network" class="md-nav__link">
    2.2.7 Feed Forward Network
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#228-residual-connections" class="md-nav__link">
    2.2.8 Residual Connections
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#229-layer-normalization" class="md-nav__link">
    2.2.9 Layer Normalization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2210-dropout-optimizer" class="md-nav__link">
    2.2.10 Dropout &amp; Optimizer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2211-output-layer" class="md-nav__link">
    2.2.11 Output Layer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-bert" class="md-nav__link">
    2.3 BERT
  </a>
  
    <nav class="md-nav" aria-label="2.3 BERT">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#231-architektur" class="md-nav__link">
    2.3.1 Architektur
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#232-masked-language-model" class="md-nav__link">
    2.3.2 Masked Language Model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#233-next-sentence-prediction" class="md-nav__link">
    2.3.3 Next Sentence Prediction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#234-pre-training" class="md-nav__link">
    2.3.4 Pre-Training
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#235-fine-tuning" class="md-nav__link">
    2.3.5 Fine-Tuning
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#24-fine-tuning" class="md-nav__link">
    2.4 Fine-Tuning
  </a>
  
    <nav class="md-nav" aria-label="2.4 Fine-Tuning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#241-aufgaben" class="md-nav__link">
    2.4.1 Aufgaben
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#242-overfitting" class="md-nav__link">
    2.4.2 Overfitting
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25-generative-pre-training" class="md-nav__link">
    2.5 Generative Pre-Training
  </a>
  
    <nav class="md-nav" aria-label="2.5 Generative Pre-Training">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#251-architektur-pre-training" class="md-nav__link">
    2.5.1 Architektur / Pre-Training
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#252-fine-tuning" class="md-nav__link">
    2.5.2 Fine-Tuning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#253-reward-model" class="md-nav__link">
    2.5.3 Reward Model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#254-reinforcement-learning" class="md-nav__link">
    2.5.4 Reinforcement Learning
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26-meta-learning" class="md-nav__link">
    2.6 Meta-Learning
  </a>
  
    <nav class="md-nav" aria-label="2.6 Meta-Learning">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#261-zero-shot-learning" class="md-nav__link">
    2.6.1 Zero-Shot Learning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#262-one-shot-learning" class="md-nav__link">
    2.6.2 One-Shot Learning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#263-few-shot-learning" class="md-nav__link">
    2.6.3 Few-Shot Learning
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#27-benchmarking" class="md-nav__link">
    2.7 Benchmarking
  </a>
  
    <nav class="md-nav" aria-label="2.7 Benchmarking">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#271-glue" class="md-nav__link">
    2.7.1 GLUE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#272-superglue" class="md-nav__link">
    2.7.2 SuperGLUE
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#273-squad" class="md-nav__link">
    2.7.3 SQuAD
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#274-modelle" class="md-nav__link">
    2.7.4 Modelle
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-anwendungen" class="md-nav__link">
    3 Anwendungen
  </a>
  
    <nav class="md-nav" aria-label="3 Anwendungen">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-limitationen-heutiger-large-language-models" class="md-nav__link">
    3.1 Limitationen heutiger Large Language Models
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-die-losung-langchain" class="md-nav__link">
    3.2 Die Lösung: LangChain
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-code-demo-der-allwissende-podcast-schreiber" class="md-nav__link">
    3.3 Code Demo: Der allwissende Podcast Schreiber
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-eine-neue-art-des-programmierens-prompt-engineering" class="md-nav__link">
    3.4 Eine Neue Art des Programmierens: Prompt Engineering
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-open-source-alternativen" class="md-nav__link">
    3.5 Open Source Alternativen
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-fazit" class="md-nav__link">
    4 Fazit
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-weiterfuhrendes-material" class="md-nav__link">
    5 Weiterführendes Material
  </a>
  
    <nav class="md-nav" aria-label="5 Weiterführendes Material">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-podcast" class="md-nav__link">
    5.1 Podcast
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-talk" class="md-nav__link">
    5.2 Talk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-demo" class="md-nav__link">
    5.3 Demo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-literaturliste" class="md-nav__link">
    6 Literaturliste
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="large-language-models">Large Language Models</h1>
<p>von <em>Richard Kelnhofer, Nick Thomas und Daniel Stoffel</em></p>
<h2 id="abstract">Abstract</h2>
<p>Das Arbeiten ohne Hilfe von ChatGPT, GitHubCopilot, etc. ist inzwischen für viele Menschen nur schwer vorstellbar. Diese Sogenannten LLMs(Large Language Models) haben innerhalb kürzester Zeit nach ihrer Veröffentlichung die Welt im Sturm erobert. Ihre Fähigkeit, Syntax, Zusammenhang und Semantik zu verstehen, macht sie zu unglaublich performanten und unerschöpflichen Assistenten für jeden, der Zugriff auf das Internet hat. Somit wurde in den letzten Jahren eine neue Generation von Assistenzsystemen geboren, welche einen bedeutenden Wert für die Menschheit bieten. Dieser Bericht umfasst drei unterschiedliche Module, welche sich von oberflächlichem Verständnis über detaillierte Informationen bis zur Anwendung strecken.</p>
<p>Der <strong>Podcast</strong> dieses Beitrags versucht Laien, aber auch Informatiker in den Bereich der LLMs einzuführen. Zunächst wird ein kleiner Teaser über die Funktionsweise der unterliegenden Technologien gegeben. Anschließend wird über die Anwendungsgebiete dieser LLMs diskutiert und es wird erläutert, welche Modifikationen ChatGPT besonders machen. Am Ende des Podcasts kommen wir zum Resultat, dass LLMs auch Gefahren bergen und so mit verfälschten Trainingsdaten (absichtlich oder versehentlich) zur Desinformation der Bevölkerung führen könnte. Die Kontrolle und Verantwortung liegt hier bei den Unternehmen, die diese Modelle erschaffen.</p>
<p>Der <strong>Fachvortrag</strong> geht äußerst detailliert auf alle Aspekte der Transformer-Modelle ein, wie z.B. Tokenisierung, Attention-Mechanismen und die generelle Architektur. Am Ende werden des weiteren Key-Features von ChatGPT, wie das Reward-Model ausführlich erläutert.</p>
<p>In der <strong>Code-Demo</strong> wird eine Library namens "LangChain" vorgestellt, welche es einfach macht, Das Wissen von LLMs zu erweitern(oder aktualisieren), mit LLMs komplexe Aufgaben zu lösen, und diese evtl. sogar in Reihe zu schalten. "LangChain" ist in den letzten Jahren zu der bekanntesten Python-Library für das Arbeiten mit LLMs geworden. In der Demo wird die Anwendung einiger Funktionen anhand des Bespiels der Generierung eines Podcast-Scripts gezeigt und hier verwendet um eigene PDFs in die Wissensbasis des Vortrainierten GPT3.5 einführen zu lassen.</p>
<h2 id="1-einleitung-motivation">1 Einleitung / Motivation</h2>
<p>Large Language Models(LLMs) sind eine der größten Neuerungen im Bereich der Künstlichen Intelligenz und haben seit ihrer Erscheinung bereits viele Menschen in Angst um ihre Arbeitsplätze versetzt.  Startschuss für diese Flut an LLMs waren die sogenannten "Transformer" Modelle, welche erstmals 2017 von Forschern von Google präsentiert wurden und RNNs(Recurrent Neural Networks) in NLP(Natural Language Processing)-Tasks den Kampf ansagten. Im Gegensatz zu RNNs, welche schwer trainierbar auf große Datenmengen waren, konnten die Transformer problemlos Unmengen an Daten verarbeiten. Sie verfügen ebenso über sogenannte "Attention" und "Self-Attention", welche sie äußerst passend für sequenzielle Probleme macht.</p>
<p>Mit diesen Eigenschaften in ihrer Architektur können Transformer, Wortposition, Wortbedeutung und Satz-Syntax selbst ganz ohne Handbenannte Daten lernen. Dies macht sie trainierbar auf exorbitanten Datenmengen, was ihre Fähigkeiten und Bandbreite ihres Wissens im Vergleich zu herkömmlichen Methoden enorm steigert.</p>
<p>Fast alle modernen LLMs basieren auf genau dieser Transformer-Technologie, erweitern sie aber wie z.B. bei ChatGPT mit handbenannte Daten und sogenannten "Reward-Models", welche dem Transformer Feedback geben können. ChatGPT ist zwar das bekannteste, aber bei weitem nicht das Einzige LLM. Es gibt zahlreiche kreative Anwendungsmöglichkeiten, welche auf Transformer bauen, die wir hier kurz präsentieren möchten.</p>
<p><strong>AutoGPT</strong> zum Beispiel ist ein Spezielles Modell, welches versucht eine Aufgabe so gut wie möglich zu absolvieren. Das Besondere ist, dass es dabei Google benutzen kann, aber auch Ordner auf dem Computer erstellen kann.</p>
<p><strong>MiniGPT</strong> ist ein Open-Source ChatBot, welcher "sehen" kann und somit auch mit Bildern arbeiten kann.</p>
<p>Zu guter Letzt gibt es <strong>perplexity.ai</strong>, eine kostenlose KI-Suchmaschine, welche bei ihren Antworten auch die Quellen der Informationen angibt.</p>
<p>Dies sind nur ein Paar Beispiele, für welche Anwendungen LLMs bereits verwendet werden. Ihre Anzahl wird in den kommenden Jahren wohlmöglich explodieren.</p>
<h2 id="2-methoden">2 Methoden</h2>
<p>In diesem Abschnitt werden verschiedene wichtige Konzepte und Techniken im Bereich des Natural Language Processing (NLP) behandelt. Es wird auf die grundlegenden Bausteinen des Transformer-Modells eingegangen, das eine Revolution in der NLP-Forschung und -Anwendung darstellt. Der Transformer ist die Grundlage für viele fortschrittliche Modelle, einschließlich BERT (Bidirectional Encoder Representations from Transformers) und GPT (Generative Pre-Training). Neben der Beschreibung der Architektur und Funktionsweise von Transformer, BERT und GPT werden auch wichtige Aspekte wie Tokenisierung, Embeddings, Positional Encoding und Fine-Tuning behandelt. Des Weiteren werden Konzepte wie Meta-Learning und Benchmarking erläutert, die zur Weiterentwicklung und Evaluierung von NLP-Motdellen beiragen. Somit wird ein umfassender Überblick über die aktuellen Schlüsselkonzepten und Techniken im Bereich des NLP gegeben.</p>
<h3 id="21-daten">2.1 Daten</h3>
<hr />
<p>Daten bilden das Herzstück der modernen Sprachverarbeitung und intensive Forschung wird in diesem Bereich betrieben, um immer fortschrittlichere Vektorrepräsentationen für Wörter zu entwickeln. Diese repräsentativen Vektoren werden auch als <strong>Embeddings</strong> bezeichnet und bilden die Grundlage für die meisten Modelle im Bereich der natürlichen Sprachverarbeitung (NLP). Dieser Abschnitt widmet sich den zentralen Konzepten und Techniken zur Erstellung von Embeddings – angefangen bei der Tokenisierung, die den Text in einzelne Token zerlegt, bis hin zu den Embeddings selbst, welche die Wörter in einem Vektorraum abbilden.</p>
<h4 id="211-tokenisierung">2.1.1 Tokenisierung</h4>
<p>In der Literatur gibt es sehr viele Tokenisierungstechniken. Hier werden nur ein paar davon näher betrachtet. Den Anfang machen die regelbasierten Tokenizer, deren Regeln von Menschen erstellt werden. Typische Tokenisierungsregeln sind:</p>
<ul>
<li>
<p>Trennung an Satzzeichen</p>
</li>
<li>
<p>Trennung an Leerzeichen</p>
</li>
<li>
<p>Trennung an Sonderzeichen</p>
</li>
</ul>
<p>Ein Beispiel für einen regelbasierten Tokenizer ist der <a href="https://www.nltk.org/_modules/nltk/tokenize/treebank.html">Penn Treebank Tokenizer</a>. Dieser Tokenizer ist in der Lage, die Tokens eines Textes zu extrahieren. Dabei werden die Tokens an Leerzeichen, Satzzeichen und Sonderzeichen getrennt. Im Kern verwendet er reguläre Ausdrücke, um die Tokens zu extrahieren. Weitergehend kann man auch auf Klein- und Großschreibung achten und diese Regeln in den Tokenizer einbauen. Zusätzlich kann man auch Lemmatizer und Stemmer verwenden, um die Tokens zu normalisieren.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">nltk.tokenize</span> <span class="kn">import</span> <span class="n">TreebankWordTokenizer</span>

<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">TreebankWordTokenizer</span><span class="p">()</span>
<span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;I can&#39;t wait to visit the U.S. next year.&quot;</span>
<span class="n">tokens</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="s1">&#39;ca&#39;</span><span class="p">,</span> <span class="s2">&quot;n&#39;t&quot;</span><span class="p">,</span> <span class="s1">&#39;wait&#39;</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">,</span> <span class="s1">&#39;visit&#39;</span><span class="p">,</span> <span class="s1">&#39;the&#39;</span><span class="p">,</span> <span class="s1">&#39;U.S.&#39;</span><span class="p">,</span> <span class="s1">&#39;next&#39;</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">]</span>
</code></pre></div>
<p>Das Ergebnis eines Tokenizers ist ein <strong>Vokabular</strong>, aus dem durch Embeddingalgorithmen Vektoren für Sprachmodelle entstehen. Dieses Vokabular ist das Fundament auf dem die Embeddings aufbauen. Es ist wichtig, dass das Vokabular möglichst groß ist, um eine gute Repräsentation der Sprache zu erreichen. Ein großes Vokabular hat aber auch Nachteile. Es ist sehr rechenintensiv und benötigt viel Speicher. Deshalb wird das Vokabular meistens auf die 30.000 häufigsten Wörter beschränkt. Jedoch gibt es auch Modelle mit weitaus größerem Vokabular. Zusätzlich muss das Vokabular nicht nur aus reinen Wörter bestehen. Was Regeln nicht erreichen, ist eine sinnvolle Trennung des Wortes <code>U.S.</code>. Regeln verstehen die Semantik hinter Abkürzungen nicht. Deshalb genügen reine regelbasierte Tokenizer nicht mehr.</p>
<p>Ein weiteres Vorgehen, um ein sinnvolles Vokabular zu erzeugen ist <a href="">Byte-Pair-Encoding</a>. Bevor man BPE verwenden, muss man seine Texte normalisieren. Auf diesen normalisierten Text wird ein Pre-Tokenizer angewendet, um Tokens zu generiern. Danach wird das Vokabular erstellt. Dieses Vokabular besteht aus den einzelnen Zeichen des Textes. Anschließend wird das Vokabular durchlaufen und die häufigsten Zeichenpaare gesucht. Diese werden dann zu einem neuen Zeichen zusammengefasst. Dieser Vorgang wird so oft wiederholt, bis das Vokabular die gewünschte Größe erreicht hat. Das Ergebnis ist ein Vokabular, das aus Zeichen und Zeichenpaaren besteht. Dieses Vokabular wird dann verwendet, um die Tokens zu generieren.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">tokenizers</span> <span class="kn">import</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">pre_tokenizers</span><span class="p">,</span> <span class="n">decoders</span><span class="p">,</span> <span class="n">trainers</span>

<span class="c1"># Initialize the BPE tokenizer</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">Tokenizer</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">BPE</span><span class="p">())</span>

<span class="c1"># Create and configure the trainer</span>
<span class="n">trainer</span> <span class="o">=</span> <span class="n">trainers</span><span class="o">.</span><span class="n">BpeTrainer</span><span class="p">(</span><span class="n">vocab_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">special_tokens</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&lt;s&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;pad&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;/s&gt;&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;unk&gt;&quot;</span><span class="p">])</span>

<span class="c1"># Train the tokenizer on your text data</span>
<span class="n">tokenizer</span><span class="o">.</span><span class="n">train</span><span class="p">([</span><span class="s2">&quot;path/to/your/text/file.txt&quot;</span><span class="p">],</span> <span class="n">trainer</span><span class="p">)</span>

<span class="c1"># Encode a sentence using the trained tokenizer</span>
<span class="n">sentence</span> <span class="o">=</span> <span class="s2">&quot;Hello, how are you?&quot;</span>
<span class="n">encoded_sentence</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>

<span class="c1"># Get the tokenized representation</span>
<span class="n">tokens</span> <span class="o">=</span> <span class="n">encoded_sentence</span><span class="o">.</span><span class="n">tokens</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
</code></pre></div>
<h4 id="212-subword-tokenization">2.1.2 Subword Tokenization</h4>
<p>Hier werden <a href="https://huggingface.co/docs/tokenizers/v0.13.3/en/api/models#tokenizers.models.BPE">WordPiece</a>, <a href="https://huggingface.co/docs/tokenizers/v0.13.3/en/api/models#tokenizers.models.WordPiece">Unigram</a> und <a href="https://github.com/google/sentencepiece">SentencePiece</a> vorgestellt. Diese Tokenizer sind sehr ähnlich zu BPE. Dennoch erstellen alle 4 Verfahren andere Vokabelsets. WordPiece ist ein Tokenisierungsalgorithmus, der ursprünglich von Google für das NLP-Modell BERT (Bidirectional Encoder Representations from Transformers) entwickelt wurde. Es ist ein statistisches Verfahren, das auf der Idee basiert, häufige Zeichenfolgen von Zeichen in einem Textkorpus zu identifizieren und sie zu einem neuen Wort zusammenzufassen. WordPiece überprüft, ob es sinvoll ist, k Zeichen zu einem neuen Zeichen zusammenzufassen. Dieser Vorgang wird so oft wiederholt, bis das Vokabular die gewünschte Größe erreicht hat.</p>
<div class="arithmatex">\[
max_{w \in V} \frac{count(\sum\limits_1^k w_k)}{\prod\limits_1^k count(w_k)}
\]</div>
<p>Das Unigram Vorgehen ist aus einem bestehenden Vokabular, unnötiges zu entfernen. Um das "Unnötige" zu bestimmen, berechnet Unigram den gesamten loss über das Vokabular mit dem Log-Likelihood. Das Vokabular wird dann so lange verkleinert, bis die gewünschte Größe erreicht ist.</p>
<div class="arithmatex">\[
 Loss = -\sum\limits_{w \in V} log(P(w))
\]</div>
<p>Zu Letzt wird noch SentencePiece vorgestellt. Dieser Tokenizer ist ein weiteres Verfahren, um Subwords zu generieren. Es ist ein statistisches Verfahren, das auf der Idee basiert, häufige Zeichenfolgen in einem Textkorpus zu identifizieren und sie zu einem neuen Wort zusammenzufassen. Dabei basiert SentencePiece auf BPE, WordPiece, Unigram und vielen anderen.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">tokenizers</span> <span class="kn">import</span> <span class="n">Tokenizer</span><span class="p">,</span> <span class="n">models</span><span class="p">,</span> <span class="n">pre_tokenizers</span><span class="p">,</span> <span class="n">decoders</span><span class="p">,</span> <span class="n">trainers</span>

<span class="c1"># Initialize the WordPiece tokenizer</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">Tokenizer</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">WordPiece</span><span class="p">())</span>

<span class="c1"># Initialize the Unigram tokenizer</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">Tokenizer</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Unigram</span><span class="p">())</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">sentencepiece</span> <span class="k">as</span> <span class="nn">spm</span>

<span class="c1"># Train SentencePiece tokenizer</span>
<span class="n">spm</span><span class="o">.</span><span class="n">SentencePieceTrainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="nb">input</span><span class="o">=</span><span class="s1">&#39;input.txt&#39;</span><span class="p">,</span> <span class="n">model_prefix</span><span class="o">=</span><span class="s1">&#39;spm_model&#39;</span><span class="p">,</span> <span class="n">vocab_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Load trained SentencePiece tokenizer</span>
<span class="n">tokenizer</span> <span class="o">=</span> <span class="n">spm</span><span class="o">.</span><span class="n">SentencePieceProcessor</span><span class="p">()</span>
<span class="n">tokenizer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;spm_model.model&#39;</span><span class="p">)</span>
</code></pre></div>
<h4 id="213-embeddings">2.1.3 Embeddings</h4>
<p>In diesem Abschnitt werden die Idee, die Speicherung und verschiedene Algorithmen und Modelle vorgestellt, durch die Embeddings erzeugt werden können. Embeddings sind der weitere Schritt in der Datenverarbeitung nach dem Erstellen des Vokabulars durch Tokenizer. Das Ziel ist es die Wörter in eine Computer verständliche Form zu bringen. Dies wird erreicht, indem die Wörter in einen Vektor umgewandelt werden. Dieser Vektor zeigt die Beziehungen zwischen einzelnen Wörtern an.</p>
<div class="admonition info">
<p class="admonition-title">Definition<p>Die grundlegende Idee hinter Embeddings besteht darin, dass ähnliche Wörter ähnliche Vektoren besitzen, was dazu führt, dass sie im n-dimensionalen Raum räumlich nah beieinander liegen.</p>
</p>
</div>
<blockquote>
<p>“An embedding is a way of representing data as points in n-dimensional space so that similar data points cluster together.”</p>
</blockquote>
<figure>
<p><img alt="space" src="../img/llms/embedding_space.png" width="400" />
  </p>
<figcaption>Fig. Basic Function</figcaption>
</figure>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">gensim.models</span> <span class="kn">import</span> <span class="n">Word2Vec</span>
<span class="kn">from</span> <span class="nn">tabulate</span> <span class="kn">import</span> <span class="n">tabulate</span>

<span class="c1"># Define the word list</span>
<span class="n">words</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;love&quot;</span><span class="p">,</span> <span class="s2">&quot;coding&quot;</span><span class="p">,</span> <span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;great&quot;</span><span class="p">,</span> <span class="s2">&quot;Machine&quot;</span><span class="p">,</span> <span class="s2">&quot;learning&quot;</span><span class="p">,</span> <span class="s2">&quot;fascinating&quot;</span><span class="p">]</span>

<span class="c1"># Create a list of sentences</span>
<span class="n">sentences</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;love&quot;</span><span class="p">,</span> <span class="s2">&quot;coding&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Python&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;great&quot;</span><span class="p">],</span>
             <span class="p">[</span><span class="s2">&quot;Machine&quot;</span><span class="p">,</span> <span class="s2">&quot;learning&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;fascinating&quot;</span><span class="p">]]</span>

<span class="c1"># Train the Word2Vec model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Word2Vec</span><span class="p">(</span><span class="n">sentences</span><span class="p">,</span> <span class="n">min_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Create a word correlation matrix</span>
<span class="n">correlation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)))</span>

<span class="c1"># Populate the correlation matrix</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">word1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">word2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
        <span class="n">correlation_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">wv</span><span class="o">.</span><span class="n">similarity</span><span class="p">(</span><span class="n">word1</span><span class="p">,</span> <span class="n">word2</span><span class="p">)</span>

<span class="c1"># Create a table with row and column headers</span>
<span class="n">table</span> <span class="o">=</span> <span class="p">[[</span><span class="n">word</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">correlation_matrix</span><span class="p">)]</span>

<span class="c1"># Add column headers</span>
<span class="n">table</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">words</span><span class="p">)</span>

<span class="c1"># Print the table</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tabulate</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">headers</span><span class="o">=</span><span class="s2">&quot;firstrow&quot;</span><span class="p">,</span> <span class="n">tablefmt</span><span class="o">=</span><span class="s2">&quot;grid&quot;</span><span class="p">))</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span>             <span class="o">|</span>           <span class="n">I</span> <span class="o">|</span>        <span class="n">love</span> <span class="o">|</span>      <span class="n">coding</span> <span class="o">|</span>      <span class="n">Python</span> <span class="o">|</span>         <span class="ow">is</span> <span class="o">|</span>       <span class="n">great</span> <span class="o">|</span>    <span class="n">Machine</span> <span class="o">|</span>    <span class="n">learning</span> <span class="o">|</span>   <span class="n">fascinating</span> <span class="o">|</span>
<span class="o">+=============+=============+=============+=============+=============+============+=============+============+=============+===============+</span>
<span class="o">|</span> <span class="n">I</span>           <span class="o">|</span>  <span class="mi">1</span>          <span class="o">|</span> <span class="o">-</span><span class="mf">0.144546</span>   <span class="o">|</span>  <span class="mf">0.00882618</span> <span class="o">|</span>  <span class="mf">0.0605919</span>  <span class="o">|</span>  <span class="mf">0.0270575</span> <span class="o">|</span> <span class="o">-</span><span class="mf">0.0690033</span>  <span class="o">|</span>  <span class="mf">0.0749756</span> <span class="o">|</span>  <span class="mf">0.199121</span>   <span class="o">|</span>    <span class="mf">0.0336406</span>  <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="n">love</span>        <span class="o">|</span> <span class="o">-</span><span class="mf">0.144546</span>   <span class="o">|</span>  <span class="mi">1</span>          <span class="o">|</span>  <span class="mf">0.0048425</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0577458</span>  <span class="o">|</span>  <span class="mf">0.0929172</span> <span class="o">|</span> <span class="o">-</span><span class="mf">0.028491</span>   <span class="o">|</span> <span class="o">-</span><span class="mf">0.0136798</span> <span class="o">|</span> <span class="o">-</span><span class="mf">0.00275401</span> <span class="o">|</span>   <span class="o">-</span><span class="mf">0.115555</span>   <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="n">coding</span>      <span class="o">|</span>  <span class="mf">0.00882618</span> <span class="o">|</span>  <span class="mf">0.0048425</span>  <span class="o">|</span>  <span class="mi">1</span>          <span class="o">|</span>  <span class="mf">0.0191523</span>  <span class="o">|</span>  <span class="mf">0.0161347</span> <span class="o">|</span>  <span class="mf">0.0347649</span>  <span class="o">|</span>  <span class="mf">0.0415774</span> <span class="o">|</span>  <span class="mf">0.145951</span>   <span class="o">|</span>   <span class="o">-</span><span class="mf">0.114107</span>   <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="n">Python</span>      <span class="o">|</span>  <span class="mf">0.0605919</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0577458</span>  <span class="o">|</span>  <span class="mf">0.0191523</span>  <span class="o">|</span>  <span class="mi">1</span>          <span class="o">|</span> <span class="o">-</span><span class="mf">0.0598763</span> <span class="o">|</span>  <span class="mf">0.13888</span>    <span class="o">|</span>  <span class="mf">0.13149</span>   <span class="o">|</span>  <span class="mf">0.0640898</span>  <span class="o">|</span>    <span class="mf">0.00939116</span> <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="ow">is</span>          <span class="o">|</span>  <span class="mf">0.0270575</span>  <span class="o">|</span>  <span class="mf">0.0929172</span>  <span class="o">|</span>  <span class="mf">0.0161347</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0598763</span>  <span class="o">|</span>  <span class="mi">1</span>         <span class="o">|</span> <span class="o">-</span><span class="mf">0.0277504</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.111671</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0523467</span>  <span class="o">|</span>   <span class="o">-</span><span class="mf">0.0108392</span>  <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="n">great</span>       <span class="o">|</span> <span class="o">-</span><span class="mf">0.0690033</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.028491</span>   <span class="o">|</span>  <span class="mf">0.0347649</span>  <span class="o">|</span>  <span class="mf">0.13888</span>    <span class="o">|</span> <span class="o">-</span><span class="mf">0.0277504</span> <span class="o">|</span>  <span class="mi">1</span>          <span class="o">|</span> <span class="o">-</span><span class="mf">0.0446171</span> <span class="o">|</span>  <span class="mf">0.170189</span>   <span class="o">|</span>    <span class="mf">0.00450302</span> <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="n">Machine</span>     <span class="o">|</span>  <span class="mf">0.0749756</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0136798</span>  <span class="o">|</span>  <span class="mf">0.0415774</span>  <span class="o">|</span>  <span class="mf">0.13149</span>    <span class="o">|</span> <span class="o">-</span><span class="mf">0.111671</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0446171</span>  <span class="o">|</span>  <span class="mi">1</span>         <span class="o">|</span> <span class="o">-</span><span class="mf">0.0135149</span>  <span class="o">|</span>    <span class="mf">0.067976</span>   <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="n">learning</span>    <span class="o">|</span>  <span class="mf">0.199121</span>   <span class="o">|</span> <span class="o">-</span><span class="mf">0.00275401</span> <span class="o">|</span>  <span class="mf">0.145951</span>   <span class="o">|</span>  <span class="mf">0.0640898</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0523467</span> <span class="o">|</span>  <span class="mf">0.170189</span>   <span class="o">|</span> <span class="o">-</span><span class="mf">0.0135149</span> <span class="o">|</span>  <span class="mi">1</span>          <span class="o">|</span>   <span class="o">-</span><span class="mf">0.0236717</span>  <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
<span class="o">|</span> <span class="n">fascinating</span> <span class="o">|</span>  <span class="mf">0.0336406</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.115555</span>   <span class="o">|</span> <span class="o">-</span><span class="mf">0.114107</span>   <span class="o">|</span>  <span class="mf">0.00939116</span> <span class="o">|</span> <span class="o">-</span><span class="mf">0.0108392</span> <span class="o">|</span>  <span class="mf">0.00450302</span> <span class="o">|</span>  <span class="mf">0.067976</span>  <span class="o">|</span> <span class="o">-</span><span class="mf">0.0236717</span>  <span class="o">|</span>    <span class="mi">1</span>          <span class="o">|</span>
<span class="o">+-------------+-------------+-------------+-------------+-------------+------------+-------------+------------+-------------+---------------+</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1"># Print the model</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="n">Output</span><span class="p">:</span>
<span class="n">Word2Vec</span><span class="o">&lt;</span><span class="n">vocab</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">vector_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.025</span><span class="o">&gt;</span>


<span class="c1"># Print the word vector for the word &quot;I&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">wv</span><span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">])</span>

<span class="n">Output</span><span class="p">:</span>
<span class="p">[</span><span class="o">-</span><span class="mf">9.5785465e-03</span>  <span class="mf">8.9431154e-03</span>  <span class="mf">4.1650687e-03</span>  <span class="mf">9.2347348e-03</span>
  <span class="mf">6.6435025e-03</span>  <span class="mf">2.9247368e-03</span>  <span class="mf">9.8040197e-03</span> <span class="o">-</span><span class="mf">4.4246409e-03</span>
 <span class="o">-</span><span class="mf">6.8033109e-03</span>  <span class="mf">4.2273807e-03</span>  <span class="mf">3.7290000e-03</span> <span class="o">-</span><span class="mf">5.6646108e-03</span>
  <span class="mf">9.7047603e-03</span> <span class="o">-</span><span class="mf">3.5583067e-03</span>  <span class="mf">9.5494064e-03</span>  <span class="mf">8.3472609e-04</span>
 <span class="o">-</span><span class="mf">6.3384566e-03</span> <span class="o">-</span><span class="mf">1.9771170e-03</span> <span class="o">-</span><span class="mf">7.3770545e-03</span> <span class="o">-</span><span class="mf">2.9795230e-03</span>
  <span class="mf">1.0416972e-03</span>  <span class="mf">9.4826873e-03</span>  <span class="mf">9.3558477e-03</span> <span class="o">-</span><span class="mf">6.5958775e-03</span>
  <span class="mf">3.4751510e-03</span>  <span class="mf">2.2755705e-03</span> <span class="o">-</span><span class="mf">2.4893521e-03</span> <span class="o">-</span><span class="mf">9.2291720e-03</span>
  <span class="mf">1.0271263e-03</span> <span class="o">-</span><span class="mf">8.1657059e-03</span>  <span class="mf">6.3201892e-03</span> <span class="o">-</span><span class="mf">5.8000805e-03</span>
  <span class="mf">5.5354391e-03</span>  <span class="mf">9.8337233e-03</span> <span class="o">-</span><span class="mf">1.6000033e-04</span>  <span class="mf">4.5284927e-03</span>
 <span class="o">-</span><span class="mf">1.8094003e-03</span>  <span class="mf">7.3607611e-03</span>  <span class="mf">3.9400971e-03</span> <span class="o">-</span><span class="mf">9.0103243e-03</span>
 <span class="o">-</span><span class="mf">2.3985039e-03</span>  <span class="mf">3.6287690e-03</span> <span class="o">-</span><span class="mf">9.9568366e-05</span> <span class="o">-</span><span class="mf">1.2012708e-03</span>
 <span class="o">-</span><span class="mf">1.0554385e-03</span> <span class="o">-</span><span class="mf">1.6716016e-03</span>  <span class="mf">6.0495257e-04</span>  <span class="mf">4.1650953e-03</span>
 <span class="o">-</span><span class="mf">4.2527914e-03</span> <span class="o">-</span><span class="mf">3.8336217e-03</span> <span class="o">-</span><span class="mf">5.2816868e-05</span>  <span class="mf">2.6935578e-04</span>
 <span class="o">-</span><span class="mf">1.6880632e-04</span> <span class="o">-</span><span class="mf">4.7855065e-03</span>  <span class="mf">4.3134023e-03</span> <span class="o">-</span><span class="mf">2.1719194e-03</span>
  <span class="mf">2.1035396e-03</span>  <span class="mf">6.6652300e-04</span>  <span class="mf">5.9696771e-03</span> <span class="o">-</span><span class="mf">6.8423809e-03</span>
 <span class="o">-</span><span class="mf">6.8157101e-03</span> <span class="o">-</span><span class="mf">4.4762576e-03</span>  <span class="mf">9.4358288e-03</span> <span class="o">-</span><span class="mf">1.5918827e-03</span>
 <span class="o">-</span><span class="mf">9.4292425e-03</span> <span class="o">-</span><span class="mf">5.4504158e-04</span> <span class="o">-</span><span class="mf">4.4489228e-03</span>  <span class="mf">6.0000787e-03</span>
 <span class="o">-</span><span class="mf">9.5836855e-03</span>  <span class="mf">2.8590010e-03</span> <span class="o">-</span><span class="mf">9.2528323e-03</span>  <span class="mf">1.2498009e-03</span>
  <span class="mf">5.9991982e-03</span>  <span class="mf">7.3973476e-03</span> <span class="o">-</span><span class="mf">7.6214634e-03</span> <span class="o">-</span><span class="mf">6.0530235e-03</span>
 <span class="o">-</span><span class="mf">6.8384409e-03</span> <span class="o">-</span><span class="mf">7.9183402e-03</span> <span class="o">-</span><span class="mf">9.4990805e-03</span> <span class="o">-</span><span class="mf">2.1254970e-03</span>
 <span class="o">-</span><span class="mf">8.3593250e-04</span> <span class="o">-</span><span class="mf">7.2562015e-03</span>  <span class="mf">6.7870365e-03</span>  <span class="mf">1.1196196e-03</span>
  <span class="mf">5.8288667e-03</span>  <span class="mf">1.4728665e-03</span>  <span class="mf">7.8936579e-04</span> <span class="o">-</span><span class="mf">7.3681297e-03</span>
 <span class="o">-</span><span class="mf">2.1766580e-03</span>  <span class="mf">4.3210792e-03</span> <span class="o">-</span><span class="mf">5.0853146e-03</span>  <span class="mf">1.1307895e-03</span>
  <span class="mf">2.8833640e-03</span> <span class="o">-</span><span class="mf">1.5363609e-03</span>  <span class="mf">9.9322954e-03</span>  <span class="mf">8.3496347e-03</span>
  <span class="mf">2.4156666e-03</span>  <span class="mf">7.1182456e-03</span>  <span class="mf">5.8914376e-03</span> <span class="o">-</span><span class="mf">5.5806171e-03</span><span class="p">]</span>
</code></pre></div>
<p>Im einfachsten Fall, liegt ein Wert pro Spalte zwischen 0 und 1. Dieser Wert gibt an, wie stark das Wort mit dem jeweiligen Merkmal korreliert. Wenn der Wert 0 ist, ist die Korrelation zwischen dem Wort und dem Merkmal nicht vorhanden. Wenn der Wert 1 ist, ist die Korrelation zwischen dem Wort und dem Merkmal sehr stark. In der Praxis werden die Werte jedoch nicht immer zwischen 0 und 1 liegen. Die Werte können auch negativ sein oder größer als 1 werden.</p>
<p>Um bei einen Embedding herauszufinden, wie ähnlich sich zwei Wortvektoren sind, wird der Cosinus-Abstand, euklidische Abstand oder das Skalarprodukt verwendet. Die Ergebnis des Skalarprodukts ist ein skalarer Wert. Wenn das Skalarprodukt von a · b einen Wert nahe der Null hat, sind die Vektoren senkrecht zueinander und haben somit keine Korrelation. Wenn das Skalarprodukt positiv ist, sind die Vektoren ähnlich oder parallel, während ein negatives Skalarprodukt auf eine entgegengesetzte oder divergierende Ausrichtung der Vektoren hinweist.</p>
<div class="arithmatex">\[ a \cdot b = a_1 * b_1 + ... + a_n * b_n \]</div>
<p>Die Aussagekraft des euklidischen Abstandes ist besser als die des Skalarproduktes. Als Ergebnis kommt ein skalarer Wertraus, der die Distanz zwischen den Vektoren angibt. Je kleiner der Wert, desto ähnlicher sind die Vektoren. Jedoch wird der Wert durch die Komponenten der Vektor stark beeinflusst. An sich wird der Differenzenvektor von a und b berechnet, an dem die euklidische Norm verwendet wird. Die euklidische Norm ist die Länge eines Vektors.</p>
<p>Den Abstand zweier Vektoren darf man für das Ähnlichkeitsmaß nutzen, da folgende Gleichungen erfüllt sind:</p>
<ul>
<li>
<p>Kommutativgesetz: $ ||x, y|| = ||y, x|| $</p>
</li>
<li>
<p>Hilbert Norm: $ ||x|| = \sqrt{x \cdot x} $</p>
</li>
<li>
<p>Cauchy-Schwarz-Ungleichung: $ |x \cdot y| \leq ||x|| * ||y|| $</p>
</li>
<li>
<p>Homogenität: $ ||\alpha * x|| = |\alpha| * ||x|| $</p>
</li>
<li>
<p>Nichtnegativität: $ ||x|| \geq 0 $</p>
</li>
</ul>
<div class="arithmatex">\[ d(a,b) = ||a - b||\_2 = \sqrt{\prod\limits_k^n (a_k - b_k)^2} \]</div>
<p>Das wichtigste Maß für die Entscheidung über Ähnlichkeit ist die Cosinus-Ähnlichkeit. Sie ist definiert als der Kosinus des Winkels zwischen den beiden Vektoren, somit liegen die Werte zwischen -1 und 1, wobei 1 für perfekte Ähnlichkeit steht.</p>
<div class="arithmatex">\[ cos(\theta) = \frac{a \cdot b}{||a||_2 * ||b||_2} \]</div>
<p>Die Berechnung der Ähnlichkeit, hilft nicht nur beim trainieren von Sprachmodellen, sonderen ist auch ein effizienter Weg Vektoren zu speichern. Für die Speicherung werden <strong>Vektor Datenbanken</strong> verwendet. Hierbei unterscheident man in eine reine Indeximplementierung wie <a href="https://www.pinecone.io/learn/faiss/">FAISS</a> oder ein Datenbankmanagement System wie <a href="https://www.pinecone.io/">Pinecone</a>. Je nach Anwendungszweck muss entschieden werden, ob Geschwiningkeit oder Sicherheit wichtiger ist.
Ein Vektor-Datenbankmanagesystem liefert die gängigen Werkzeuge, um die Speicherung von Vektoren zu verwalten. Dazu gehören die folgenden Funktionen:</p>
<ul>
<li>
<p>Data Management: Speichern, Abrufen, Löschen und Aktualisieren von Vektoren</p>
</li>
<li>
<p>Indexing: Erstellen von Indizes für die Suche</p>
</li>
<li>
<p>Metadata Management: Speichern von Metadaten zu Vektoren</p>
</li>
<li>
<p>Scalability &amp; Integration: Skalierung und Integration in bestehende Systeme</p>
</li>
<li>
<p>Real-Time updates: Echtzeit-Updates von Vektoren</p>
</li>
<li>
<p>Backups &amp; Collection: Backups und Sammlungen von Vektoren(Window-Functions)</p>
</li>
<li>
<p>Security &amp; access control: Sicherheit und Zugriffskontrolle</p>
</li>
</ul>
<p>Ein Index hat vieles davon nicht. Dementsprechend muss man sicher sehr sicher sein, falls man die Indeximplementierung wählt. Andernfalls werden einzelne Funktionen selbst implementiert, was zu einem Mehraufwand führt.</p>
<figure>
<p><img alt="db" src="../img/llms/embedding_db.png" width="400" />
  </p>
<figcaption>Fig. Vector Database</figcaption>
</figure>
<p>Vektoren werden durch Algorithmen wie <em>Product Quantinization</em>, <em>Locality Sensitive Hashing</em> oder <em>Hierarchical Navigable Small World</em> in einen Index umgewandelt. Dieser Index landet mit dem dazugehörigen Originalvektor in der Vektor Datenbank. Beim Querying wird der Query-Vektor in den Index umgewandelt und mit den Indexvektoren verglichen. Die Ergebnisse werden dann zurückgegeben. Schließlich kommt es zum Postprocessing, bei dem die Ergebnisse gefiltert und / oder geordnet werden. Somit kommt es zu einer Neubewertung aller Ergebnisse und das beste Ergebnis wird zurückgegeben.</p>
<p>Product Quantization ist eine Technik, die in der Vektorquantisierung verwendet wird, um hochdimensionale Vektoren durch eine kleinere Menge von Prototypvektoren zu repräsentieren und somit zu komprimieren. Das Ziel von Product Quantization besteht darin, den Speicherbedarf hochdimensionaler Vektoren zu reduzieren, während ihre wesentlichen Merkmale erhalten bleiben. Somit wird der originale Vektor in mehrere Subvektoren aufgeteilt, die einzeln quantisiert werden. Die Quantisierung wird durch <em>centroids</em> durchgeführt. Das sind Vektoren (<em>reproduction values</em>), die sich in einem Subraum befinden, wo die Komponenten der Subvektoren ihre nächsten Nachbarn suchen, indem diese k-nearest-neighbours (kNN) verwenden. Folglich wird auf das naheste reproduction value gemappt, um den Vektor zu repräsentieren.</p>
<figure>
<p><img alt="pq" src="../img/llms/embedding_pq.png" width="400" />
  </p>
<figcaption>Fig. Product Quantinization</figcaption>
</figure>
<p>Jetzt wo das sicher der Vektoren klargestellt ist, kann man anfangen Embeddings zu berechnen. Der bekannteste Ansatz ist <em>Word2Vec</em>. Hierzu gibt es zwei Architekturen: <em>Continuous Bag of Words</em> und <em>Skip-Gram</em>. Beide Architekturen sind neural network language models. Das Ziel ist es, die Wahrscheinlichkeit eines Wortes zu berechnen, das auf ein anderes Wort folgt. Die Architektur des CBOW-Modells und des Skip-Gram-Modells ist in der folgenden Abbildung dargestellt.</p>
<figure>
<p><img alt="w2v" src="../img/llms/embedding_w2v.png" width="400" />
  </p>
<figcaption>Fig. Word2Vec</figcaption>
</figure>
<p>Das Ziel des CBOW ist es, ein Wort innerhalb eines Kontextes vorherzusagen, während das Ziel des Skip-Grams die Vorhersage desKontextes um ein Wort ist. Beide verwenden ein hidden layer ohne Aktivierungsfunktion. Folglich findet eine Projektion statt, indem das Skalarprodukt von Eingabevektor und Gewichtsmatrix gebildet wird. Schließlich wird in der Ausgabe Schicht ein hierachischer Softmax verwendet. Er nutzt einen binären Baum, um die Wahrscheinlichkeit eines Wortes zu berechnen. Anstatt alle Wörter im Vokabular zu berücksichtigen, wird der hierarchische Softmax die Wahrscheinlichkeit schrittweise berechnen, indem er den Baum durchläuft. Dieser Baum organisiert die Wörter hierarchisch, wobei häufigere Wörter näher an der Wurzel und seltenere Wörter weiter unten im Baum platziert werden. Indem der hierarchische Softmax den binären Baum verwendet, kann er die Anzahl der Berechnungen reduzieren, da er nur einen Teil des Baums durchlaufen muss, um die Wahrscheinlichkeit eines bestimmten Wortes zu bestimmen. Dies führt zu einer beschleunigten Vorhersagephase und ermöglicht die effiziente Verarbeitung großer Vokabulare. Zum Vallidieren der Ausgaben wird One-Hot-Encoding verwendet.</p>
<figure>
<p><img alt="bt" src="../img/llms/embedding_binary_tree.png" width="400" />
  </p>
<figcaption>Fig. hierachischer Softmax</figcaption>
</figure>
<p>Zum Trainieren wird sub sampling als auch negative sampling verwendet. Sub sampling überprüft von vorne weg, ob ein Wort in das Context Fenster aufgenommen wird oder nicht. Ein Context Fenster entsteht, um ein betrachtetes Wort und seine direkten Nachbarn. Die Wahrscheinlichkeit, dass ein Wort in das Context Fenster aufgenommen wird, ist umgekehrt proportional zu seiner Häufigkeit.</p>
<div class="arithmatex">\[ P(w_i) = (\sqrt{\frac{z(w_i)}{0.001}} + 1) * \frac{0.001}{z(w_i)} \]</div>
<p>Negative sampling ist eine Technik, die die Trainingszeit verkürzt, indem sie nur eine kleine Anzahl von negativen Beispielen und das positive Beispiel auswählt, um die Gewichte zu aktualisieren. Bei einer großen Anzahl von Perzeptronen in der Eingabeschicht kann das Training lange dauern, wenn man alle Gewichte anpasssen muss, obwohl man nur pro Wort anpasst. Die Anzahl der negativen Beispiele ist ein Hyperparameter, der die Genauigkeit und die Trainingszeit beeinflusst. Die Formel für die Berechnung der Wahrscheinlichkeit eines negativen Beispiels ist wie folgt:</p>
<div class="arithmatex">\[ P(w*i) = \frac{z(w_i)^{3/4}}{\sum_{j=0}^{n} z(w_j)^{3/4}} \]</div>
<figure>
<p><img alt="ns" src="../img/llms/embedding_negative_sampling.png" width="400" />
  </p>
<figcaption>Fig. negative sampling</figcaption>
</figure>
<p>Die Erweiterung von Word2Vec ist Fasttext, das von Facebook 2017 veröffentlicht wurde. Es berücktsichtigt die Morphologie von Wörtern. Im Gegensatz zu Word2Vec, das Wörter als diskrete Einheiten betrachtet, betrachtet Fasttext Wörter als eine Reihe von Zeichen oder n-Grammen. Somit wird es robuster gegen unbekannte Wörter. Das Resultat ist eine "Tasche" von verschiedenen n-Grammen zu einem Wort. Dies hat zur Folge, dass eine geteilte Repräsentation über Wörtern entsteht und somit die Repräsentation von seltenen Wörtern verbessert wird. Die Vorhersage, basiert auf eine Score-Funktion, die die Summe der Vektoren der n-Gramme des Wortes ist. Die Score-Funktion ist wie folgt definiert:</p>
<div class="arithmatex">\[ s(w, c) = \sum\limits_{g \in G_w} z_g^T v_c \]</div>
<ul>
<li>
<p>G ist die Menge der n-Gramme zu einem Wort w</p>
</li>
<li>
<p>z ist der Vektor eines n-Gramms</p>
</li>
<li>
<p>v ist der Vektor des zugehörigen Kontexts</p>
</li>
</ul>
<p>Es können auch Language Models für Embeddings verwendet werden. Ein Beispiel ist <em>GloVe</em>. Es verwendet eine Matrix, um die Beziehung zwischen Wörtern zu erfassen. Hierbei wird betrachtet wie oft Wörter miteinander in einem Kontext auftauchen. Mit der SVG (Singularwertzelegung) wird die ursprüngliche Matrix in kleiner Matrizen geteilt. Dabei werden die Wortembeddings erzeugt.
Dennoch werden Embeddings auch mit Transformer Modellen wie Bert und GPT erstellt. Diese werden in den nächsten Kapitel genauer betrachtet. Doch ein weiteres Modell ist interessant: <em>ELMo</em>(Embeddings from Language Models). ELMo basiert auf einem didirektionalen LSTM. Das hat den Vorteil, dass Sequenzen von beiden Richtungen durchgegangen werden können.</p>
<div class="arithmatex">\[ ELMo_k^{task} = E(R_k; \theta^{task}) = \gamma^{task}\sum\limits_{j=0}^L s_j^{task} h_{k, j}^{LM} \]</div>
<ul>
<li>
<p><span class="arithmatex">\(\gamma^{task}\)</span> ist ein Skalarparameter, der für jede Aufgabe trainiert wird und den ELMo Vektor skaliert</p>
</li>
<li>
<p><span class="arithmatex">\(s_j^{task}\)</span> sind softmax-normalisierte Gewichte, die für jede Aufgabe trainiert werden</p>
</li>
<li>
<p><span class="arithmatex">\(h_{k, j}^{LM}\)</span> ist der j-te hidden LSTM Zustand für das k-te Token</p>
</li>
<li>
<p><span class="arithmatex">\(R_k\)</span> ist die Repräsentation des k-ten Tokens</p>
</li>
<li>
<p><span class="arithmatex">\(\theta^{task}\)</span> sind die Parameter der Aufgabe</p>
</li>
<li>
<p><span class="arithmatex">\(ELMo_k^{task}\)</span> ein einziger Vektor aus der Reduzierung aller Schichten in R</p>
</li>
</ul>
<p>LSTMs können durch ihre Zellen und rekusiver Natur für Sequenzverarbeitung verwendet werden. Die Zellen sind in der Lage, Informationen über einen längeren Zeitraum zu speichern und diese zu filtern. Die rekursive Natur eines LSTM kommt daher, dass es eine Verbesserung des RNNs ist. Das wichtigste für die Embeddinggenerierung ist es, dass die resultierenden Embeddings kontextabhängig sind. Die LSTM-Zellen liefern den Kontext, indem sie die vorherigen Ausgaben berücksichtigen. Ein weiterer Vorteil einer LSTM-Architektur ist es, dass pro Zelle über den Hidden State eine Vektorrepräsentation entsteht. Diese Vektorrepräsentationen werden für die Embeddinggenerierung verwendet. Somit glit für die linke Seite: <span class="arithmatex">\(\vec{h}_{k, j}^{LM}\)</span> für <span class="arithmatex">\(t_{k+1}\)</span> und für die rechte Seite gilt: <span class="arithmatex">\(\overleftarrow{h}_{k, j}^{LM}\)</span> für <span class="arithmatex">\(t_{k}\)</span>.</p>
<p>Um diese Vektorrepräsentationen zu erzeugen, muss ELMo trainiert werden. Dies geschieht, indem die Wahrscheinlichkeit für das Vorkommen eines Wortes innerhalb einer Sequenz maximiert wird und die aufkommenden Fehler minimiert werden. Die Wahrscheinlichkeit wird wie folgt berechnet:</p>
<div class="arithmatex">\[ 
max(
    \sum\limits_{k=1}^{K}
        log P(t_k | t_1, ..., t_{k-1}; \theta_x, \vec\theta_{LSTM}, \theta_s) +
        log P(t_t | t_{k+1}, ..., t_K; \theta_x, \overleftarrow{\theta}_{LSTM}, \theta_s))
\]</div>
<p>Anhand der Gleichung sieht man genau, dass die Sequenzen von beiden Richtungen durchgegangen werden. Um die Wahrscheinlichkeit für das Vorkommen eines Wortes innerhalb einer Sequenz zu berechnen, wird in der Bedingung jeweils die linke oder rechte Seite verwendet. Zusätzlich werden noch die zugehörigen Gewichtsmatrizen <span class="arithmatex">\(\theta_x, \vec\theta_{LSTM}, \overleftarrow{\theta}_{LSTM}, \theta_s\)</span> in die Wahrscheinlichkeitsberechnung mit rein gerechnet. Schließlich kann jedes Token als eine Menge von Vektorrepräsentaion dargestellt werden. Die Größer einer solchen Menge ist abhängig von der Anzahl der LSTM-Zellen, wodruch sich folgende Gleichung ergibt: <span class="arithmatex">\(size(R_t) = 2 * L + 1\)</span>, wobei L die Anzahl der LSTM-Zellen ist. Somit lässt sich jedes Token als eine Menge von Vektorrepräsentationen darstellen.</p>
<div class="arithmatex">\[ R_t = \{x_k^{LM}, \vec{h}_{k, j}^{LM}, \overleftarrow{h}_{k, j}^{LM} | j = 1, ... , L\} \]</div>
<figure>
<p><img alt="elmo" src="../img/llms/embedding_elmo.png" width="400" />
  </p>
<figcaption>Fig. ELMo</figcaption>
</figure>
<p>Zu guter letzt muss man noch mutli-sense embeddings betrachten. Hier versucht man die Mehrdeutigkeit von Wörtern abzubilden. Mögliche Ansätze sind:</p>
<ul>
<li>
<p>Sense2Vec</p>
</li>
<li>
<p>ELMo + Clustering</p>
</li>
<li>
<p>Transformer</p>
</li>
</ul>
<p>Speziell benutzt man clustering Methoden, um die Mehrdeutigkeit von Wörtern abzubilden. Hierbei werden die Embeddings von Wörtern in Cluster unterteilt, wobei pro Cluster ein neue Repräsentation des Wortes entsteht. Um dies zu erreichen, werden cluster Algorithmen benötigt, die mit hochdimensonalen Vektoren umgehen können. Beispiele sind: K-Means, DBSCAN, Mean-Shift, Affinity Propagation, Spectral Clustering, Hierarchical Clustering, Gaussian Mixture Models und noch viele mehr. Im folgenden werden die Algorithmen K-Means und Mean-Shift genauer betrachtet.</p>
<p>K-Means ist ein iterativer Algorithmus, der versucht die Daten in k Cluster zu unterteilen. Hierbei wird die Distanz zwischen den Datenpunkten und den Clusterzentren minimiert. Die Clusterzentren werden durch den Mittelwert der Datenpunkte gebildet. Der Algorithmus funktioniert wie folgt:</p>
<ol>
<li>
<p>Wähle k zufällige Punkte als Clusterzentren</p>
</li>
<li>
<p>Berechne die Distanz zwischen den Datenpunkten und den Clusterzentren</p>
</li>
<li>
<p>Weise jeden Datenpunkt dem nächstgelegenen Clusterzentrum zu</p>
</li>
<li>
<p>Berechne die neuen Clusterzentren</p>
</li>
<li>
<p>Wiederhole Schritt 2 bis 4, bis sich die Clusterzentren konvergieren</p>
</li>
</ol>
<p>Der Algorithmus ist einfach zu implementieren und schnell in der Ausführung. Doch er hat auch Nachteile. Zum einen muss die Anzahl der Cluster k bekannt sein. Zum anderen ist der Algorithmus anfällig für Ausreißer, was zu falschen Clusterzentren führen kann.</p>
<p>Mean-Shift ist ein iterativer Algorithmus, der auf der Idee basiert, dass Datenpunkte zur lokalen Dichtemaxima tendieren. Er kann verwendet werden, um natürliche Cluster in Daten zu finden, ohne die Anzahl der Cluster im Voraus zu kennen. Somit benötig man einen Kernel, den man vorab initialisieren muss. Meistens wird hierfür der Gauß-Kernel verwendet. <span class="arithmatex">\(K(x) = \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}\)</span>. Danach kann die Suche nach den lokalen Dichtemaxima beginnen. Der Algorithmus funktioniert wie folgt:</p>
<ol>
<li>
<p>Wähle einen Datenpunkt als Startpunkt</p>
</li>
<li>
<p>Berechne den Kreis mit Radius r um den Startpunkt</p>
</li>
<li>
<p>Berechne den Schwerpunkt der Datenpunkte innerhalb des Kreises</p>
</li>
<li>
<p>Setze den Schwerpunkt als neuen Mittelpunkt</p>
</li>
<li>
<p>Wiederhole Schritt 2 bis 4, bis sich die Mittelpunkte konvergieren</p>
</li>
</ol>
<p>Somit wird der Mittelpunkt immer näher an das lokale Dichtemaxima herangeführt, da die Datenpunkte innherhalb des Kreises immer mehr werden sollen. Diese Eingenschaft des Algorithmus wird auch als hill climbing bezeichnet.</p>
<figure>
<p><img alt="msc" src="../img/llms/embedding_msc.png" width="400" />
  </p>
<figcaption>Fig. Mean Shift</figcaption>
</figure>
<p>Ein Vorteil von Mean-Shift-Clustering ist, dass es automatisch die Anzahl der Cluster bestimmt, da die Cluster durch die lokalen Maxima der Datenpunktdichte definiert werden. Der Algorithmus ist auch robust gegenüber Rauschen und kann Cluster mit komplexen Formen erfassen. Allerdings kann die Performance des Algorithmus bei großen Datensätzen beeinträchtigt sein, da er eine hohe Rechenleistung erfordert, um die Dichte in einem hochdimensionalen Raum zu berechnen.</p>
<h3 id="22-transformer">2.2 Transformer</h3>
<hr />
<p>Der Transformer ist ein fortschrittliches neuronales Netzwerkmodell, das in der natürlichen Sprachverarbeitung (NLP) weit verbreitet ist. Er wurde erstmals 2017 in einem bahnbrechenden Paper namens "Attention is All You Need" vorgestellt. Im Gegensatz zu traditionellen rekurrenten und faltenden Architekturen hat der Transformer in NLP-Aufgaben wie maschineller Übersetzung, Textklassifikation und Spracherkennung für Aufsehen gesorgt. Das Kernkonzept des Transformers ist die Verwendung von Self-Attention-Mechanismen, die es dem Modell ermöglichen, relevante Teile der Eingabe zu identifizieren und deren Beziehungen zu modellieren. Der Transformer nutzt auch andere Techniken wie Positional Encoding, um die Positionsinformationen der Eingabesequenzen zu berücksichtigen, und Multi-Head Attention, um verschiedene Aufmerksamkeitsrepräsentationen zu erfassen. Darüber hinaus umfasst der Transformer Residual Connections und Layer Normalization, um den Trainingsprozess zu stabilisieren, sowie Dropout, um Overfitting zu verhindern. Der Optimizer steuert die Aktualisierung der Modellparameter, während die Ausgabeschicht die Vorhersagen des Modells erzeugt. Insgesamt bietet der Transformer eine effiziente Verarbeitung von Sequenzdaten und ist zu einem grundlegenden Modell in der NLP-Forschung und -Anwendung geworden.</p>
<figure>
<p><img alt="T" src="../img/llms/transformer_a.png" width="400" />
  </p>
<figcaption>Fig. Transformer Architektur</figcaption>
</figure>
<div class="admonition info">
<p class="admonition-title">Wichtig<p>Die Transformer Architektur ist die <strong>state of the art</strong> Architektur für NLP Aufgaben.</p>
</p>
</div>
<h4 id="221-positional-encoding">2.2.1 Positional Encoding</h4>
<p>Positional Encoding wird verwendet, um die Positionsinformationen der Eingabesequenzen in den Wortembeddings zu berücksichtigen. Da der Transformer keine rekurrenten oder faltenden Schichten enthält, müssen die Positionsinformationen explizit in das Modell integriert werden. Das Positional Encoding wird den Wortembeddings hinzugefügt und ermöglicht es dem Transformer, die relative Position der Wörter in der Eingabesequenz zu berücksichtigen.</p>
<p>Es besteht aus Sinus- und Kosinus-Funktionen mit unterschiedlichen Frequenzen und Phasen. Die Idee dahinter ist, dass die Kombination dieser Funktionen eine eindeutige Repräsentation für jede Position in der Sequenz erzeugt. Das Positional Encoding wird dann elementweise zu den Wortembeddings addiert, um die Information über die Positionen in den Gesamtvektor einzufügen.</p>
<p>Die Formel für das Positional Encoding lautet:</p>
<div class="arithmatex">\[ PE_{(pos, 2i)} = \sin (\frac{pos}{10000^{2i/d_{\text{model}}}})\]</div>
<div class="arithmatex">\[ PE_{(pos, 2i+1)} = \cos (\frac{pos}{10000^{2i/d_{\text{model}}}}) \]</div>
<p>Hierbei steht <span class="arithmatex">\(pos\)</span> für die Position in der Sequenz, <span class="arithmatex">\(i\)</span> für die Dimension des Wortembeddings und <span class="arithmatex">\(d_{\text{model}}\)</span> für die Größe des Wortembeddings. Das Positional Encoding hat die gleiche Dimension wie die Wortembeddings, sodass es direkt zu ihnen addiert werden kann.</p>
<figure>
<p><img alt="POE" src="../img/llms/POE.png" width="400" />
  </p>
<figcaption>Fig. positional encoding</figcaption>
</figure>
<p>Durch schafft man es, dass die Position von Wörtern in unterschiedlichen Satzlängen gleich repräsentiert werden. Den sowohl <span class="arithmatex">\(i\)</span> als auch <span class="arithmatex">\(d_{\text{model}}\)</span> sind konstant, sodass die Positionsinformationen von einzelnen Wörtern an der gleichen Stelle nicht von der Länge der Eingabesequenz abhängen.</p>
<figure>
<p><img alt="POE2" src="../img/llms/POE2.png" width="400" />
  </p>
<figcaption>Fig. positional encoding Tabelle: (i, pos) </figcaption>
</figure>
<p>Durch die Verwendung des Positional Encoding kann der Transformer die Positionsinformationen der Wörter berücksichtigen, ohne dass hierfür rekurrente oder faltende Schichten benötigt werden. Dies ermöglicht dem Modell, sowohl die Bedeutung der Wörter als auch ihre Position in der Sequenz zu erfassen und komplexe Zusammenhänge zwischen ihnen zu erlernen, die auf längere Sequenzen verallgemeinert werden können. Dadurch könnte das Modell effektiv Eingabesequenzen unterschiedlicher Längen verarbeiten.
Vereinfacht lässt es sich so darstellen:</p>
<div class="arithmatex">\[ pe_{k} = \frac{1}{10000^{2k/d_{\text{model}}}} \]</div>
<div class="arithmatex">\[\begin{bmatrix}
e_0  \\
e_1  \\
e_2  \\
e_3  \\
...  \\
e_n  \\
\end{bmatrix}_{d_n \times 1} + \begin{bmatrix}
\sin(pe_1 * 1) \\ 
\cos(pe_1 * 1) \\ 
\sin(pe_2 * 1) \\ 
\cos(pe_2 * 1) \\
... \\ 
\sin(pe_{n/2} * 1) \\ 
\cos(pe_{n/2} * 1) \\
\end{bmatrix}_{d_n \times 1}\]</div>
<h4 id="222-architektur">2.2.2 Architektur</h4>
<p>Der Encoder schafft ein Verständnis für die Eingabesequenz, indem er die Embeddings durch mehrere hintereinandere kommende <em>Attenttion</em> und <em>fully connected feed forward</em> Schichten verarbeitet. Ein Encoder-Schicht besteht aus einer <em>multi-head self attention</em> und einem <em>fully connected feed forward network</em>. Diese beiden werden Subschichten genannt. Zwishcen den Subschichten gibt es <em>residual connections</em> und <em>layer normalization</em>, um das Netzwerk zu stabilisieren und die Trainingszeit zu verkürzen. Die Aufgabe des Encoders ist es, eine Repräsentation der Eingabesequenz zu erzeugen, wo die Bedeutung der Wörter, ihre Position in der Sequenz, Merkmale und globale Abhängigkeiten berücksichtigt werden, damit der Decoder die Ausgabe erzeugen kann.</p>
<figure>
<p><img alt="EC" src="../img/llms/Encoder.png" width="400" />
  </p>
<figcaption>Fig. Encoder - Layer </figcaption>
</figure>
<p>Der Decoder generiert die Ausgabe des Transformer Modelles. Eine Schicht des Decoders besteht aus einer <em>masked multi-head attention</em> gefolgt von einer <em>mulit-head cross-attention</em> und schließlich einem <em>fully connected feed forward network</em>. Diese drei Schichten sind die Subschichten einer Decoder-Schicht. Die <em>masked multi-head attention</em> Schicht ist eine <em>multi-head attention</em> Schicht, die eine Maske verwendet, um die Aufmerksamkeit auf die zukünftigen Wörter zu beschränken. Die <em>multi-head cross-attention</em> Schicht verwendet die Ausgabe der <em>masked multi-head attention</em> Schicht als Query und die Ausgabe des Encoders als Key und Value. Die Berechnung der <em>masked attention</em> gleicht der, der <em>self attention</em>. Somit wird dem Decoder ermöglicht, die Ausgabe des Encoders zu verwenden, um die Bedeutung der Wörter in der Eingabesequenz zu verstehen und die Ausgabe zu erzeugen. Die <em>fully connected feed forward network</em> Schicht ist die gleiche wie im Encoder. Der Decoder verwendet auch <em>residual connections</em> und <em>layer normalization</em> zwischen den Subschichten, um das Modell weiter zu stabilisieren.</p>
<figure>
<p><img alt="DC" src="../img/llms/Decoder.png" width="500" />
  </p>
<figcaption>Fig. Decoder - Layer </figcaption>
</figure>
<p>Attention ist ein zentrales Konzept in Transformer-Modellen und ermöglicht es dem Modell, sich auf relevante Teile der Eingabesequenz zu konzentrieren oder relevante Informationen zu extrahieren. Der Sinn von Attention besteht darin, die Verbindungen und Abhängigkeiten zwischen verschiedenen Teilen der Eingabesequenz zu erfassen und diese Informationen in der Modellverarbeitung zu berücksichtigen. Die Attention kann in verschiedene Typen unterteilt werden, die in den folgenden Abschnitten beschrieben werden.</p>
<figure>
<p><img alt="A" src="../img/llms/Attention.png" width="600" />
  </p>
<figcaption>Fig. Attention Typen </figcaption>
</figure>
<h4 id="223-self-attention">2.2.3 Self-Attention</h4>
<p>Self-attention wird auch als <em>intra</em> oder <strong>scaled dot product</strong> attention bezeichnet. Wie der Name schon vorwegnimmt, geht es darum verschiedenste Vektoren durch das Skalarprodukt zu verrechnen, um die Relevanz zwischen einzelnen Positionen zu berechnen. Somit wird jeder Vektor in einen Query, Key und Valuevektor zerlegt, wobei die Dimension dieser drei Vektoren kleiner ist als zum Originalvektor. Um Query, Key und Value Vektoren zu erhalten, muss man den Original Vektor mit drei spezifischen Gewichtsmatrizen multiplizieren.</p>
<div class="arithmatex">\[Q = XW^Q; K = XW^K; V = XW^V\]</div>
<p>Die Gewichtsmatrizen werden während des Trainings gelernt. Die Dimension der Gewichtsmatrizen ist <span class="arithmatex">\(d_{\text{model}} \times d_k\)</span> für <span class="arithmatex">\(W^Q\)</span> und <span class="arithmatex">\(W^K\)</span> und <span class="arithmatex">\(d_{\text{model}} \times d_v\)</span> für <span class="arithmatex">\(W^V\)</span>. Die Dimension des Originalvektors wird als <span class="arithmatex">\(d_{\text{model}}\)</span> bezeichnet und <span class="arithmatex">\(d_k\)</span> als auch <span class="arithmatex">\(d_v\)</span> sind die Dimensionen der Query, Key und Value Vektoren.</p>
<figure>
<p><img alt="A2" src="../img/llms/Attention2.png" width="200" />
  </p>
<figcaption>Fig. Self-Attention </figcaption>
</figure>
<p>Als erstes wird das Skalarprodukt zwischen den Query und Key Vektoren berechnet. Das Skalarprodukt wird durch die Division mit <span class="arithmatex">\(\sqrt{d_k}\)</span> skaliert. Die Skalierung ist wichtig, da sie bei der Berechnung der Aufmerksamkeitsgewichte hilft, die Varianz der Werte zu reduzieren und die Stabilität der Gradienten zu verbessern. Danach folgt die Anwendung der Softmax Funktion, um die Summe aller positiven Wert auf 1 bringen und damit das Ergebnis zu normalisieren. Schließlich werden alle Value Vektoren mit dem Softmax Ergebnis multipliziert, um wichtige Informationen zu verstärken und unwichtige Informationen zu unterdrücken. Das Ergebnis ist die Summe aller gewichteten Value Vektoren. Die Self-Attention Formel kann wie folgt dargestellt werden, wenn man die Matrixmultiplikationen berücksichtigt:</p>
<div class="arithmatex">\[\text{Attention}(Q, K, V) = \text{softmax}(\frac{QK^T}{\sqrt{d_k}})V\]</div>
<p>Das Ergebnis der self-attention wird dann angepasst durch <em>residual connections</em> und <em>layer normalization</em>, was dann in das <em>feed forward network</em> eingespeist wird.</p>
<h4 id="224-cross-attention">2.2.4 Cross-Attention</h4>
<p>Cross-attention wird auch als <em>inter</em> attention bezeichnet. Die Brechnung ist gleich der, der self-attention, wobei die Query Vektoren aus dem Decoder kommen und die Key und Value Vektoren aus dem Encoder. Die cross-attention Formel kann wie folgt dargestellt werden:</p>
<div class="arithmatex">\[\text{Attention}(Q_D, K_E, V_E) = \text{softmax}(\frac{Q_DK_E^T}{\sqrt{d_k}})V_E\]</div>
<p>Der Zweck der Cross-Attention besteht darin, dem Decoder Kontextinformationen zu liefern, die auf den Inhalten der Eingabesequenz basieren. Dadurch kann der Decoder relevante Informationen aus der Eingabe extrahieren und sie in den Generierungsprozess der Ausgabe einbeziehen. Dies ermöglicht dem Modell eine bessere Berücksichtigung der globalen Zusammenhänge und Kontexte während der Generierung und verbessert die Leistungsfähigkeit des Modells insgesamt.</p>
<h4 id="225-masked-attention">2.2.5 Masked Attention</h4>
<p>Die Idee der Masked Attention ist es, die Aufmerksamkeit auf zukünftige Tokens zu beschränken. Dies wird erreicht, indem die Repräsentation der zukünftigen Tokens auf <span class="arithmatex">\(-\infty\)</span> gesetzt werden. Dadurch wird die Softmax Funktion dazu gezwungen, die Aufmerksamkeitsgewichte der zukünftigen Tokens auf 0 zu setzen. Die Masked Attention Formel kann wie folgt dargestellt werden:</p>
<div class="arithmatex">\[\text{Attention}(Q, K, V) = \text{softmax}(\frac{QK^TM}{\sqrt{d_k}})V\]</div>
<p>Die Maskierung in der maskierten Aufmerksamkeit besteht aus einer Matrix, die <span class="arithmatex">\(-\infty\)</span> für zukünftige Positionen und Einsen für aktuelle Positionen enthält. Diese Matrix wird auf die Aufmerksamkeitsgewichte angewendet, um sicherzustellen, dass das Modell nur auf bereits generierte Teile der Ausgabe zugreift. Eine gängige Methode für die Maskierung ist die Dreiecksmatrix. Ein Beispiel dafür:</p>
<div class="arithmatex">\[M = \begin{bmatrix}
1 &amp; -\infty &amp; -\infty &amp; -\infty &amp; -\infty \\
1 &amp; 1       &amp; -\infty &amp; -\infty &amp; -\infty \\
1 &amp; 1       &amp; 1       &amp; -\infty &amp; -\infty \\
1 &amp; 1       &amp; 1       &amp; 1       &amp; -\infty \\
1 &amp; 1       &amp; 1       &amp; 1       &amp; 1       \\
\end{bmatrix}\]</div>
<h4 id="226-multi-head-attention">2.2.6 Multi-Head Attention</h4>
<p>Die Multihead Attention ist ein Schlüsselelement in Transformer-Modellen und ermöglicht es dem Modell, mehrere Aufmerksamkeitsgewichtungen gleichzeitig zu berechnen und verschiedene Aspekte der Eingabesequenz zu erfassen. Sie besteht aus mehreren parallelen Aufmerksamkeitsköpfen, die unabhängig voneinander arbeiten. Jeder Aufmerksamkeitskopf hat seine eigenen Parametermatrizen für Query (Q), Key (K) und Value (V). Diese Matrizen werden verwendet, um die Aufmerksamkeitsgewichte für jede Position in der Eingabesequenz zu berechnen. Damit wird erreicht, dass sich das Transformer Modell auf verschiedene Aspekte der Eingabesequenz konzentrieren kann. Die Multihead Attention Formel kann wie folgt dargestellt werden:</p>
<div class="arithmatex">\[\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, ..., \text{head}_h)W^O\]</div>
<div class="arithmatex">\[\text{head}_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V)\]</div>
<p>Beim Zusammenfügen der verschiedenen <em>attention heads</em> darf kein Durchschnitt gebildet werden, ansonsten würden Informationen verloren gehen, die zuvor berechnet wurden. Deshalb werden die <em>attention heads</em> konkateniert. Schließlich muss die Dimensonalität der konkatenierten <em>attention heads</em> reduziert werden, damit die Dimensionen mit der Dimension der Eingabeschicht des feed forward network übereinstimmen. Dies wird durch die Matrix <span class="arithmatex">\(W^O\)</span> erreicht.</p>
<figure>
<p><img alt="A3" src="../img/llms/Attention3.png" width="200" />
  </p>
<figcaption>Fig. Multi-head Attention </figcaption>
</figure>
<p>An dieser Stelle ist es wichtig zu erwähnen, dass die Multihead Attention nicht nur für die self-attention verwendet wird, sondern auch für die cross-attention und die masked attention. Dank der hohen Parallelität, kann das Sprachverstehen im Transformer auf mehreren unterschiedlich tiefen Ebenen stattfinden.</p>
<h4 id="227-feed-forward-network">2.2.7 Feed Forward Network</h4>
<p>Das <em>Feed Forward Network</em> (FFN) besteht aus zwei linearen Transformationen mit einer ReLU Aktivierungsfunktion dazwischen. Das Ziel des FFNs ist es, die Aufmerksamkeitsrepräsentationen zu verfeinern und weitere komplexe Zusammenhänge über die Nicht-Linearität zu erfassen. Die Nicht-Linearität wird durch die Verwendung von Aktivierungsfunktionen wie ReLU erreicht. Die Formel für das FFN kann wie folgt dargestellt werden:</p>
<div class="arithmatex">\[\text{FFN}(x) = \text{max}(0, xW_1 + b_1)W_2 + b_2\]</div>
<p>Es wären neben der ReLU Aktivierungsfunktion auch andere Aktivierungsfunktionen möglich, wie z.B. GELU oder ELU. Die ReLU Aktivierungsfunktion ist jedoch die am häufigsten verwendete Aktivierungsfunktion in der Praxis. Die ReLU Aktivierungsfunktion ist definiert als: <span class="arithmatex">\(f(x) = \text{max}(0, x)\)</span> und ist somit effektiv und einfach umzusetzen. GELU - <em>Gaussian Error Linear Unit</em> - eine Variante der ReLU Aktivierungsfunktion ist. Sie wird auch als die geglättete ReLU-Funktion bezeichnet. Die GELU Aktivierungsfunktion ist definiert als: <span class="arithmatex">\(f(x) = x\Phi(x)\)</span>, wobei <span class="arithmatex">\(\Phi(x)\)</span> die kumulative Verteilungsfunktion der Standardnormalverteilung ist und lautet daher: <span class="arithmatex">\(\Phi(x) = \frac{1 + \text{erf}(x / \sqrt{2})}{2}\)</span> mit <span class="arithmatex">\(\text{erf}(z) = \frac{2}{\sqrt{\Pi}} * \int_{0}^{z} e^{-t^2} dt\)</span>. Die GELU Aktivierungsfunktion ist eine stetige Funktion, weshalb sie differenzierbar ist und mit negativen Zahlen subtiler verfährt, wodurch - je nach Aufgabe - eine bessere Anpassung des Modelles stattfindet. Die ELU-Funktion - <em>Exponential Linear Unit</em> - ist eine weitere Aktivierungsfunktion und ist definiert als: <span class="arithmatex">\(f(x) = x\)</span> für <span class="arithmatex">\(x &gt; 0\)</span> und <span class="arithmatex">\(f(x) = \alpha(e^x - 1)\)</span> für <span class="arithmatex">\(x \leq 0\)</span>, wobei <span class="arithmatex">\(\alpha\)</span> eine Konstante ist. Die ELU Aktivierungsfunktion ist eine stetige Funktion, die den gleichen Gedanken verfolgt wie die ReLU-Funktion. Jede dieser Funktionen kann eine Verbesserung des Modells bewirken, somit muss man diese der Aufgabe entsprechend auswählen. Die GELU-Funktion ist sehr gut bei der Verarbeitung von Texten wie zum Beispiel bei der Übersetzung von Texten. Die ELU-Funktion wiederum löst das Problem der toten Neuronen, die bei der Verwendung der ReLU-Funktion auftreten können. Die ELU-Funktion ist jedoch nicht so effizient wie die ReLU-Funktion, da sie exponentielle Funktionen verwendet. </p>
<div class="arithmatex">\[\text{ReLU}(x) = \begin{cases} x &amp; \text{if } x &gt; 0 \\ x &amp; \text{if } x \leq 0 \end{cases}\]</div>
<div class="arithmatex">\[\text{GELU}(x) = x\Phi(x)\]</div>
<div class="arithmatex">\[\text{ELU}(x) = \begin{cases} x &amp; \text{if } x &gt; 0 \\ \alpha(e^x - 1) &amp; \text{if } x \leq 0 \end{cases}\]</div>
<figure>
<p><img alt="A4" src="../img/llms/Attention4.png" width="500" />
  </p>
<figcaption>Fig. Aktivierungsfunktionen </figcaption>
</figure>
<h4 id="228-residual-connections">2.2.8 Residual Connections</h4>
<p>Mit den Residual Connections wird die Performance des Transformer Modells verbessert, indem gegen das Problem des <strong>Vanishing Gradients</strong> vorgegangen wird. Sie sind eine Art von Skip Connections, die es ermöglichen, die Informationen aus den vorherigen Schichten zu erhalten. Dabei wird die Ausgabe der vorherigen Schicht mit der Ausgabe der aktuellen Schicht addiert. Die Residual Connections werden wie folgt definiert:</p>
<div class="arithmatex">\[\text{LayerNorm}(x + \text{Sublayer}(x))\]</div>
<p>Diese werden pro Sublayer einmal angewendet und tragen somit zur Stabilisierung des Netzes bei, sowie zur Verbesserung der Erkennung von komplexen Datenmuster.</p>
<h4 id="229-layer-normalization">2.2.9 Layer Normalization</h4>
<p>Die Layer Normalization ist eine Technik, die es ermöglicht, die Aktivierungen der vorherigen Schicht zu normalisieren um den Mittelwert von 0 mit der Standardabweichung von 1. Daraus folgt, dass die eizelnen Werte weniger streuen und somit die Aktivierungen der vorherigen Schicht weniger variieren. Die Layer Normalization wird wie folgt definiert:</p>
<div class="arithmatex">\[\text{LayerNorm}(x) = \alpha \frac{x - \mu}{\sqrt{\sigma^2 + \epsilon}} + \beta\]</div>
<ul>
<li>
<p>x die Eingabeaktivierungen der Schicht</p>
</li>
<li>
<p><span class="arithmatex">\(\mu\)</span> ist der Durchschnitt der Aktivierungen über die Merkmalsdimension</p>
</li>
<li>
<p><span class="arithmatex">\(\sigma\)</span> ist die Varianz der Aktivierungen über die Merkmalsdimension</p>
</li>
<li>
<p><span class="arithmatex">\(\epsilon\)</span> ist ein kleiner Wert zur Stabilität, um eine Division durch Null zu verhindern</p>
</li>
<li>
<p><span class="arithmatex">\(\alpha\)</span> ist der skalare Parameter zur Skalierung der normalisierten Aktivierung</p>
</li>
<li>
<p><span class="arithmatex">\(\beta\)</span> ist der skalare Parameter zur Verschiebung der normalisierten Aktivierung</p>
</li>
</ul>
<p>Die Layer Normalization wird pro Schicht angewendet und trägt somit zur Stabilisierung des Netzes bei, da ähnlich große Gradientenschritte vollzogen werden und die einzelnen Wert nicht mehr zustark voneinander variieren.</p>
<figure>
<p><img alt="A5" src="../img/llms/Attention5.png" width="500" />
  </p>
<figcaption>Fig. Feature Dimension </figcaption>
</figure>
<h4 id="2210-dropout-optimizer">2.2.10 Dropout &amp; Optimizer</h4>
<p><em>Dropout</em> ist eine Regularisierungstechnik, die versucht zufällig Perzeptronen aka Neuronen zu deaktivieren, um die Generalisierung des Modells zu verbessern. Dies wird erreicht, indem die Gewichte der deaktivierten Neuronen auf 0 gesetzt werden. Die Dropout Rate ist ein Hyperparameter, der die Wahrscheinlichkeit bestimmt, mit der ein Neuron deaktiviert wird. Er liegt zwischen <span class="arithmatex">\(0.1\)</span> und <span class="arithmatex">\(0.5\)</span>. Es wird eingesetzt, um das Problem des Overfittings zu vermeiden. Dropout lässt sich wie folgt definieren: <span class="arithmatex">\(\frac{EM}{1-p}\)</span>, dabei sind <em>E</em> die Aktivierungen oder Werte der vorherigen Schicht, <em>M</em> eine binäre Maske mit derselben Form wie die Eingabe, die zufällig auf 0 oder 1 gesetzt wird und <em>p</em> die Wahrscheinlichkeit, dass eine Aktivierung deaktiviert wird. Die Binärmaske <em>M</em> wird immer wieder neu generiert und ist somit nicht statisch. </p>
<div class="arithmatex">\[M = \begin{cases} 1 &amp; \text{if } \text{Bernoulli}(p) == 1 \\ 0 &amp; \text{if } \text{Bernoulli}(p) == 0 \end{cases} \]</div>
<p>Der <em>Adam Optimizer</em> - Adaptive Momentum - ist ein Optimierungsalgorithmus, der die Lernrate für jedes Gewicht individuell anpasst. Er wird verwendet, um die Lernrate <span class="arithmatex">\(\alpha\)</span> anzupassen, sodass das globale Minimum schnellst möglich erreicht wird. Der Adam Optimizer ist eine Kombination aus dem Momentum und der adaptiven Anpassung der Lernrate. Er nutzt die Konzepte der Impulserhaltung des <em>Stochastic Gradient Descent</em> und das des <em>RMSProp</em>. Der Adam Optimizer wird wie folgt definiert:</p>
<div class="arithmatex">\[\theta_{t+1} = \theta_t - \frac{\alpha}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t\]</div>
<ul>
<li>
<p><span class="arithmatex">\(\theta_t\)</span> sind die Gewichte des Netzes</p>
</li>
<li>
<p><span class="arithmatex">\(\hat{v}_t\)</span> ist die geschätzte Varianz des Gradienten: <span class="arithmatex">\(\hat{v}_t = \beta_2 v_{t-1} + (1 - \beta_2)g_t^2\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(\hat{m}_t\)</span> ist der geschätzte Mittelwert des Gradienten: <span class="arithmatex">\(\hat{m}_t = \beta_1 m_{t-1} + (1 - \beta_1)g_t\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(\beta_1\)</span> und <span class="arithmatex">\(\beta_2\)</span> sind die Exponentialfaktoren für den Mittelwert und die Varianz</p>
</li>
<li>
<p><span class="arithmatex">\(\epsilon\)</span> ist ein kleiner Wert zur Stabilität, um eine Division durch Null zu verhindern</p>
</li>
</ul>
<figure>
<p><img alt="Adam" src="../img/llms/Adam.png" width="500" />
  </p>
<figcaption>Fig. Gradient Descent </figcaption>
</figure>
<h4 id="2211-output-layer">2.2.11 Output Layer</h4>
<p>Die Ausgabe des Transformers ist ein Vektor, der die Wahrscheinlichkeit für jedes Token im Vokabular angibt. Somit wird nur das nächste Token vorrausgesagt und dann sequentiel folgend der Rest. Die Wahrscheinlichkeit wird mit der Softmax Funktion berechnet. Die Softmax Funktion wird wie folgt definiert:</p>
<div class="arithmatex">\[\text{softmax}(z_{ij}) = \frac{e^{z_{ij}}}{\sum_{j=1}^{L} e^{z_{ij}}}\]</div>
<ul>
<li>
<p><span class="arithmatex">\(z_{ij}\)</span> ist die Aktivierung an der Position <span class="arithmatex">\(i\)</span> und <span class="arithmatex">\(j\)</span> innerhalb einer Ausgabematrix</p>
</li>
<li>
<p><span class="arithmatex">\(L\)</span> ist die Anzahl der Feautures</p>
</li>
</ul>
<p>Die Softmax Funktion wird pro Zeile angewendet und somit wird die Summe der Wahrscheinlichkeiten pro Zeile 1 ergeben.</p>
<figure>
<p><img alt="Softmax" src="../img/llms/Softmax.png" width="400" />
  </p>
<figcaption>Fig. Softmax </figcaption>
</figure>
<h3 id="23-bert">2.3 BERT</h3>
<hr />
<p>Bert, vollständig bekannt als <em>Bidirectional Encoder Representations from Transformers</em>, ist ein Transformer-Modell, das auf der Encoder-Struktur basiert. Es zählt zur Kategorie der Autoencoder-Modelle und ist darauf spezialisiert, Benutzereingaben zu verstehen und zu verarbeiten.</p>
<figure>
<p><img alt="Bert" src="../img/llms/Bert.png" width="600" />
  </p>
<figcaption>Fig. Bert </figcaption>
</figure>
<h4 id="231-architektur">2.3.1 Architektur</h4>
<p>BERT - <em>Bidirectional Encoder Representations from Transformers</em> - ist ein Modell für maschinelles Lernen, das Kontextinformationen berücksichtigt, indem es die umgebenden Wörter verwendet, was in der traditionellen Tranformerarchitektur nicht der Fall ist. BERT verwendet eine Kombination aus Masked Language Model (MLM) und Next Sentence Prediction (NSP) Aufgaben, um den Kontext zu erfassen.</p>
<figure>
<p><img alt="Bert2" src="../img/llms/Bert2.png" width="600" />
  </p>
<figcaption>Fig. Kontext </figcaption>
</figure>
<p>Die Basisarchitektur von BERT besteht aus einem Stapel von 12 Encoder-Layern. Jeder Encoder-Layer setzt sich aus einer Multi-Head Attention-Schicht und einer Feed Forward-Schicht zusammen, die ihre Verarbeitung der Eingabesquenz an das nächste Layer weitergeben. Für die Multi-Head Attention wird eine Aufteilung in 12 <em>attention heads</em> vorgenommen. Jeder Attention-Head fokussiert sich auf unterschiedliche Aspekte des Kontexts und erfasst verschiedene Beziehungen zwischen den Wörtern. Diese Vielfalt an Attention-Heads ermöglicht es BERT, verschiedene Arten von Abhängigkeiten und Zusammenhängen in der Benutzereingabe zu berücksichtigen. Die Größe der Embeddings, die BERT verwendet, beträgt 768. Das bedeutet, dass jedes Token in der Eingabe in einem Vektorraum mit einer Dimension von 768 repräsentiert wird.</p>
<figure>
<p><img alt="Bert4" src="../img/llms/Bert4.png" width="400" />
  </p>
<figcaption>Fig. Architektur </figcaption>
</figure>
<p>Bevor die Eingabe an den Encoder weitergegeben wird, wird sie durch einen Tokenizer in einzelne Token aufgeteilt. Diese Tokens werden dann in Embeddings umgewandelt, die die semantische Bedeutung der Wörter repräsentieren. Zusätzlich werden Positionsinformationen hinzugefügt, um die Reihenfolge und Zugehörigkeit der Wörter im Satz zu kodieren. Dies ist notwendig, da der Transformer-Algorithmus, auf dem BERT basiert, parallele Strukturen verwendet und die Positionsinformationen helfen, den Kontext korrekt zu erfassen.</p>
<p>Die Ausgabe des Encoders wird schließlich durch einen Softmax-Layer in Token-Wahrscheinlichkeiten umgewandelt. Diese Wahrscheinlichkeiten geben an, wie wahrscheinlich es ist, dass jedes Token an einer bestimmten Position im Satz auftritt.</p>
<figure>
<p><img alt="Bert3" src="../img/llms/Bert3.png" width="600" />
  </p>
<figcaption>Fig. Encoding </figcaption>
</figure>
<p>Bert verwendet einen WordPiece-Tokenizer, der die Eingabesätze in einzelne Tokens aufteilt. Jede Sequenz beginnt mit einem speziellen Token [CLS], gefolgt von den Tokens des ersten Satzes, dann einem Trennungs-Token [SEP], und schließlich den Tokens des zweiten Satzes, wieder gefolgt von einem Trennungs-Token [SEP].</p>
<p>Der Tokenizer kann auch Subword-Aufteilung durchführen, wobei ein Token mit dem #-Zeichen gekennzeichnet wird, um anzuzeigen, dass es in mehrere Subtokens aufgeteilt wurde. Dies ermöglicht eine flexiblere Darstellung von Wörtern, insbesondere bei seltenen oder unbekannten Wörtern.</p>
<p>Das Vokabular von Bert besteht insgesamt aus 30.000 Tokens, die zur Kodierung von Wörtern verwendet werden können. Jedes Token wird in einem Token-Embedding repräsentiert, das die semantische Bedeutung des Tokens erfasst. Zusätzlich gibt es ein Segment-Embedding, das die Zugehörigkeit eines Tokens zu einem bestimmten Satz angibt. Dadurch kann Bert zwischen den beiden Sätzen unterscheiden und den Kontext richtig erfassen. Schließlich gibt es ein Position-Embedding, das die Position jedes Tokens im Satz angibt. Dies ist wichtig, da der Transformer-Algorithmus parallele Strukturen verwendet und die Positionsinformationen helfen, den Kontext korrekt zu kodieren.</p>
<p>Zusammen bilden das Token-Embedding, das Segment-Embedding und das Position-Embedding das Gesamt-Embedding für die Eingabe von Bert. Dieses Embedding erfasst die Beziehungen zwischen den Tokens, die Zugehörigkeit zu verschiedenen Sätzen und die Position in den Sätzen, was zur präzisen Modellierung des Kontexts beiträgt.</p>
<h4 id="232-masked-language-model">2.3.2 Masked Language Model</h4>
<p>Beim <em>Masked Language Modeling</em> (MLM) in BERT wird versucht, maskierte Wörter in der Eingabesequenz vorherzusagen, um dem Modell ein grundlegendes Sprachverständnis zu ermöglichen. Dieser Prozess wird durchgeführt, indem etwa 15% der Tokens in der Eingabesequenz zufällig durch das [MASK]-Token ersetzt werden. Das Modell versucht dann, das ursprüngliche Token anhand einer Wahrscheinlichkeitsverteilung des Vokabulars zu bestimmen. Durch das Maskieren und Vorhersagen von Wörtern wird das Modell dazu angeleitet, den Kontext und die Beziehungen zwischen den Wörtern zu verstehen. Indem es den umgebenden Kontext verwendet, um die maskierten Tokens zu rekonstruieren, entwickelt das Modell ein Verständnis für die Bedeutung und Struktur von Sätzen. Die Wahrscheinlichkeiten für die vorhergesagten Wörter basieren auf einer Verteilung über das Vokabular, die durch den Softmax-Layer im BERT-Modell berechnet wird. Das Modell gibt Wahrscheinlichkeiten für jedes mögliche Token im Vokabular aus, und das wahrscheinlichste Token wird als Vorhersage für das maskierte Token genommen.</p>
<figure>
<p><img alt="Bert5" src="../img/llms/Bert5.png" width="600" />
  </p>
<figcaption>Fig. Masked Language Model </figcaption>
</figure>
<h4 id="233-next-sentence-prediction">2.3.3 Next Sentence Prediction</h4>
<p>Bei der <em>Next Sentence Prediction</em> (NSP) geht es darum, dass BERT versucht, zu bestimmen, ob ein Satz A auf einen Satz B folgt. Dieser Ansatz ermöglicht es BERT, das Verständnis für den Zusammenhang zwischen Sätzen zu erlernen. Während des Trainings wird eine Aufteilung von 50/50 verwendet, bei der BERT sowohl positive als auch negative Beispiele für die NSP-Aufgabe erhält. Positive Beispiele bestehen aus aufeinanderfolgenden Sätzen, während negative Beispiele aus zufällig ausgewählten Sätzen bestehen, die nicht in einem direkten Zusammenhang stehen. Durch diese Aufteilung wird BERT dazu angeleitet, die Beziehungen zwischen Sätzen zu verstehen und zu lernen, ob ein Satz auf den vorherigen folgt oder nicht. Dies trägt dazu bei, dass BERT ein umfassendes Verständnis des Kontexts und der Abhängigkeiten zwischen Sätzen entwickelt.</p>
<figure>
<p><img alt="Bert7" src="../img/llms/Bert7.png" width="600" />
  </p>
<figcaption>Fig. Next Sentence Prediction </figcaption>
</figure>
<p>Die Entscheidung, ob zwei Sätze aufeinander folgen, wird über die Sigmoid-Funktion getroffen. Der Klassifikator besteht in der Regel aus einem Fully Connected Layer, gefolgt von einer Sigmoid-Aktivierungsfunktion. Das Fully Connected Layer nimmt die Ausgabe des BERT-Modells und projiziert sie auf eine einzige Ausgabedimension. Diese Ausgabedimension wird dann der Sigmoid-Funktion übergeben, die eine Wahrscheinlichkeit zwischen 0 und 1 erzeugt.</p>
<div class="arithmatex">\[ \sigma(W_{NSP} \cdot [CLS]_{NSP} + b_{NSP}) \]</div>
<p>Hierbei stellt <span class="arithmatex">\(\sigma\)</span> die Sigmoid-Funktion dar, <span class="arithmatex">\(W_{\text{NSP}}\)</span> sind die Gewichte des Fully Connected Layers für die NSP-Aufgabe und <span class="arithmatex">\(b_{\text{NSP}}\)</span> ist der Bias-Term. <span class="arithmatex">\([CLS]_{NSP}\)</span> ist das Embedding des [CLS]-Tokens, das als Eingabe für den Klassifikator verwendet wird. Es beinhaltet die wichtigsten Informationen über die ganze Sequenz, wodurch es in der Lage es ist, die NSP-Aufgabe zu lösen.</p>
<h4 id="234-pre-training">2.3.4 Pre-Training</h4>
<p>Während des Trainings von BERT wird die Ausgabe des Modells für das <em>Masked Language Modeling</em> (MLM) mit One-Hot-kodierten Vektoren validiert, während die Ausgabe für die <em>Next Sentence Prediction</em> (NSP) mit einem Binärwert validiert wird. Das Modell wird mithilfe des <em>Cross-Entropy Loss</em> trainiert, wobei die Wahrscheinlichkeitsverteilung der Vorhersagen mit den tatsächlichen Werten verglichen wird. Der Loss wird nur bei den maskierten Tokens verwendet, um Trainingszeit zu sparen.</p>
<div class="arithmatex">\[ L_i = -\sum_{j=1}^{V} y_{ij} \log(\hat{y}_{ij}) \]</div>
<p>Dabei steht <span class="arithmatex">\(y_{ij}\)</span> für den tatsächlichen Wert des Labels und <span class="arithmatex">\(\hat{y}_{ij}\)</span> für die vorhergesagte Wahrscheinlichkeit des Modells für die jeweilige Klasse oder Kategorie. Der Loss wird für jedes Token oder jeden Satz berechnet und aggregiert. Das Pre-Training von BERT wird mit einer Batch-Größe von 256 und einer Lernrate von <span class="arithmatex">\(1e-4\)</span>, die mit dem  <em>Adam Optimizer</em> angepasst wird, durchgeführt. Dabei werden Cloud-TPUv3-Ressourcen verwendet.</p>
<h4 id="235-fine-tuning">2.3.5 Fine-Tuning</h4>
<figure>
<p><img alt="Bert6" src="../img/llms/Bert6.png" width="600" />
  </p>
<figcaption>Fig. Fine tuning Bert </figcaption>
</figure>
<p>Nach dem Pre-Training kann BERT für spezifische Aufgaben durch sogenanntes Fine-Tuning weiter optimiert werden. Das initiale BERT-Modell wird dabei als Ausgangspunkt verwendet, da es bereits auf das grundlegende Sprachverständnis trainiert ist. Beim Fine-Tuning werden die Parameter des vortrainierten Modells an die spezifische Aufgabe angepasst, indem bestimmte Teile des Modells mit einem Aufgabendatensatz neu trainiert werden.</p>
<p>Die Ausgabe eines feinabgestimmten BERT-Modells variiert je nach Aufgabe und erfordert die Identifizierung der relevanten Sequenzteile. Dieser Prozess unterscheidet sich von Aufgabe zu Aufgabe. Nehmen wir als Beispiel eine Frage-Antwort-Aufgabe, bei der die Antwort auf eine gestellte Frage gefunden werden soll. In diesem Fall befinden sich die relevanten Informationen, die die Antwort enthalten, hinter dem ersten [SEP]-Token in der Sequenz. Das bedeutet, dass die Tokens nach dem [SEP]-Token die Antwort repräsentieren. Bei der Textklassifikation hingegen wird die Ausgabe des Modells durch das erste [SEP]-Token dargestellt, da es die Klassifikation des Textes widerspiegelt. Hierbei ist das erste [SEP]-Token das entscheidende Element, um die Kategorie oder Klasse des Textes zu identifizieren. Die genaue Identifizierung der relevanten Sequenzteile kann je nach Aufgabe unterschiedlich sein und erfordert eine Aufgaben-spezifische Behandlung der Modellausgabe.</p>
<h3 id="24-fine-tuning">2.4 Fine-Tuning</h3>
<hr />
<p>Das Fine-Tuning-Prozess besteht darin, das vorhandene Wissen und die Sprachrepräsentationen, die im Pre-Training gelernt wurden, auf die spezifische Aufgabe anzuwenden. Hierbei werden die Gewichte des Modells aktualisiert, um die Leistung auf der spezifischen Aufgabe zu verbessern. Während des Fine-Tuning können verschiedene Schichten oder Komponenten des Modells, wie die oberen Schichten des Modells oder der Klassifikator, angepasst werden, während tiefere schichten des Modells fixiert / gefroren bleiben. Hierbei ist zu beachten, dass in den tieferen Schichten die Fähigkeit des Modelles steckt, Sprache zu verstehen, während in den oberen Schichten die Aufgabe spezifisch gelernt wird. Das Fine-Tuning kann mit einem kleineren Datensatz als der des initialen Trainings durchgeführt werden, da das Modell bereits ein grundlegendes Sprachverständnis hat. Dies ermöglicht es, dass das Modell mit nur wenigen Trainingsbeispielen gute Ergebnisse erzielt.</p>
<h4 id="241-aufgaben">2.4.1 Aufgaben</h4>
<figure>
<p><img alt="FT" src="../img/llms/FT.png" width="600" />
  </p>
<figcaption>Fig. FT-Aufgaben </figcaption>
</figure>
<p>Die Trainingsstrategie für Sprachmodelle wie BERT besteht darin, zunächst ein allgemeines Sprachverständnis zu erlernen und anschließend spezifische Aufgaben mithilfe von Labeldaten zu trainieren. Die Aufgaben, auf die ein Sprachmodell feinabgestimmt werden kann, sind vielfältig und abhängig von den spezifischen Anforderungen und Zielen. Beispiele für solche Aufgaben können in der Abbildung <em>FT-Aufgaben</em> gefunden werden, die verschiedene Anwendungsbereiche wie Textklassifikation, Named Entity Recognition, Sentimentanalyse und vieles mehr umfasst.</p>
<h4 id="242-overfitting">2.4.2 Overfitting</h4>
<figure>
<p><img alt="FT2" src="../img/llms/FT2.png" width="400" />
  </p>
<figcaption>Fig. Overfitting </figcaption>
</figure>
<p>Beim fine tuning kann es zu einem Overfitting kommen, wenn das Modell zu stark auf die Trainingsdaten angepasst wird und die Fähigkeit verliert, auf neue Daten zu generalisieren. Dies kann durch die Verwendung von Regularisierungsstrategien verhindert werden. Einige dieser Techniken sind: </p>
<ul>
<li>Dropout</li>
<li>Early Stopping</li>
<li><span class="arithmatex">\(L_1 / L_2\)</span> Regularisierung</li>
<li>Verteilungsanpassung</li>
</ul>
<p>Dropout ist eine Technik, bei der zufällig ausgewählte Neuronen während des Trainings deaktiviert werden, um zu verhindern, dass das Modell zu stark auf die Trainingsdaten angepasst wird. Early Stopping ist eine Technik, bei der das Training gestoppt wird, wenn die Leistung des Modells auf den Validierungsdaten nicht mehr verbessert wird. Dies verhindert, dass das Modell zu stark auf die Trainingsdaten angepasst wird. <span class="arithmatex">\(L_1 / L_2\)</span> Regularisierung ist eine Technik, bei der die Gewichte des Modells mit einem Strafterm belegt werden, um zu verhindern, dass das Modell zu stark auf die Trainingsdaten angepasst wird. Folglich werden die Gewichtungen geglättet und das Modell ist stabiler gegen Unbekanntes, Rauschen und Ausreißer. Dies dient dazu, dass der Verlustfunktionswert erhöht wird, wenn die Gewichte des Modells zu groß werden. Die <span class="arithmatex">\(L_1 / L_2\)</span> Regularisierung wird durch die folgenden Gleichungen definiert: <span class="arithmatex">\(L_1 = \sum_{i=1}^{n} |w_i|\)</span> und <span class="arithmatex">\(L_2 = \sum_{i=1}^{n} w_i^2\)</span>, wobei zu beachten ist, dass der Loss auch auf dem Bias berechnet werden muss. Schließlich addiert man den Loss der <span class="arithmatex">\(L_1 / L_2\)</span> Regularisierung mit dem Loss der Daten, um den Gesamtloss zu erhalten.</p>
<div class="arithmatex">\[ regularization\_loss = L_1 + L_2 \]</div>
<div class="arithmatex">\[ L = data\_loss + regularization\_loss \]</div>
<p>Das Ziel der Verteilungsanpassung besteht darin, sicherzustellen, dass die Verteilung der Daten, auf die das feinabgestimmte Modell trainiert wird, ähnlich oder vergleichbar mit der Verteilung des ursprünglichen Trainingsdatensatzes ist. Es geht darum, eine konsistente Verteilung der Daten beizubehalten, um sicherzustellen, dass das Modell auf ähnliche Beispiele und Muster trifft wie während des ursprünglichen Trainings. Es darf nicht vergessen werden, dass die Daten des fine-tuned Modelles gebündelt sind und die des pre-trained Modelles gestreut sind.</p>
<h3 id="25-generative-pre-training">2.5 Generative Pre-Training</h3>
<hr />
<p>Generative Pre-Training, kurz GPT, ist eine Architektur, die auf der Decoder-Seite von Transformers basiert. GPT zählt zu den sogenannten <em>auto-regressiven Modellen</em>. Seine herausragende Fähigkeit liegt in der Generierung von Texten, wie das aktuelle GPT-4-Modell beeindruckend demonstriert.</p>
<figure>
<p><img alt="GPT" src="../img/llms/GPT.png" width="800" />
  </p>
<figcaption>Fig. CHAT - GPT </figcaption>
</figure>
<p>Im Folgenden werden wir über die drei grundlegenden Säulen von GPT sprechen, die es zu einem beeindruckenden Sprachmodell machen: Pre-Training + Fine-Tuning, Reward Model und Reinforcement Learning. Diese drei Säulen bilden die Grundlage für das Training des Modells, um Texte zu generieren und weitere NLP-Aufgaben zu meistern. </p>
<p>Die erste Säule ist das Pre-Training + Fine-Tuning. Beim Pre-Training wird das GPT-Modell auf einer riesigen Menge an Textdaten trainiert. Hierbei wird dem Modell beigebracht, Sprachstrukturen, Zusammenhänge und Semantik zu verstehen. Dabei wird ein sogenanntes <em>unsupervised Learning</em> verwendet, bei dem das Modell keine explizite Zielvorgabe erhält, sondern selbstständig Muster und Regelmäßigkeiten im Text erkennt und generalisiert. Das Pre-Training erfolgt normalerweise auf einer großen Textsammlung, wie beispielsweise dem gesamten Internet. Nach dem Pre-Training folgt das Fine-Tuning, bei dem das Modell auf eine spezifische Aufgabe oder Domäne angepasst wird. Hierbei werden Textdaten verwendet, die durch Labeler vorbereitet werden, um das Modell auf spezifische Kontexte, Stile und Vorgaben einzustellen.</p>
<p>Die zweite Säule ist das Reward Model. Um das Modell auf bestimmte Ziele oder Präferenzen auszurichten, wird ein sogenanntes Reward Model verwendet. Das Reward Model bewertet die Qualität der generierten Texte anhand vorgegebener Kriterien wie Kohärenz, Relevanz, Grammatik oder anderen domänenspezifischen Merkmalen. Das Modell wird dann durch Reinforcement Learning darauf trainiert, die jeweiligen NLP-Aufgaben zu meistern, die ein höheres Belohnungssignal vom Reward Model erhalten. Dadurch kann das Modell lernen den gewünschten Kriterien besser entsprechen.</p>
<p>Das Reinforcement Learning ermöglicht es dem Modell, aus Erfahrung zu lernen und seine Textgenerierung kontinuierlich zu verfeinern. Indem es auf das Feedback des Reward Models reagiert und seine Strategien entsprechend anpasst, kann das Modell immer bessere Texte erzeugen, die den Anforderungen und Zielen gerecht werden.</p>
<h4 id="251-architektur-pre-training">2.5.1 Architektur / Pre-Training</h4>
<figure>
<p><img alt="GPT2" src="../img/llms/GPT2.png" width="400" />
  </p>
<figcaption>Fig. Decoder-Layout </figcaption>
</figure>
<p>Wie schon erwähnt, basiert GPT auf dem Decoder Teil des originalen Transformermodelles. Dementsprechend benötigt es, wie auch das Transformermodell, eine Eingabe, die aus einer Sequenz von Token besteht, welche durch ein Embedding-Layer in einen Vektor umgewandelt wird. Dieser Vektor bekommt zusätzlich über das positional Encoding Informationen über die Position der einzelnen Tokens. Schließlich wird der Eingabevektor durch mehrere Decoderschichten verarbeitet. </p>
<div class="arithmatex">\[ h_0 = UW_e + W_p \]</div>
<ul>
<li>
<p><span class="arithmatex">\(U\)</span> ist der Context Vektor: <span class="arithmatex">\(U = (u_{-k}, ... , u_{-1})\)</span> bei einem Corpus von <span class="arithmatex">\(C = {u_1, ... , u_n}\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(k\)</span> ist die Größe des Kontextes</p>
</li>
<li>
<p><span class="arithmatex">\(W_e\)</span> ist die Embeddingmatrix der Tokens</p>
</li>
<li>
<p><span class="arithmatex">\(W_p\)</span> ist die <em>positional encoding</em> Matrix</p>
</li>
</ul>
<p>Diese Gleichung makiert den Startpunkt von GPT, in welcher die Initialisierungsschritte des GPT-Modells dargestellt werden. Der Vektor <span class="arithmatex">\(h_0\)</span> repräsentiert den Anfangszustand des Modells, der durch eine lineare Transformation von zwei Eingabevektoren erzeugt wird. Schließlich wandern die Eingaben durch die Transformerblöcke.</p>
<div class="arithmatex">\[ h_i = TransformerBlock(h_{i-1}) \forall{i} \in [1, n]\]</div>
<p>Damit wird durch die ganzen Schichten des GPT-Modelles iteriert. Die Ausgabe des letzten Transformerblocks wird dann durch eine lineare Transformation in die Wahrscheinlichkeitsverteilung der nächsten Token umgewandelt.</p>
<div class="arithmatex">\[ P(u) = \text{softmax}(h_nW_e^T) \]</div>
<p>Die Ausgabeformell basiert auf dem Hintergrund, dass die Wahrscheinlichkeit von einem Token <span class="arithmatex">\(u\)</span> abhängt, welche Tokens im aktuellen Kontex vorausgehen. Die Wahrscheinlichkeit von <span class="arithmatex">\(u\)</span> ist also abhängig von der Wahrscheinlichkeit der vorherigen Tokens und der Parameter des Modells. </p>
<div class="arithmatex">\[P(u_i | u_{i-k}, ... , u_{i-1}; \theta)\]</div>
<p>Das Modelle optimiert somit die Wahrscheinlichkeit <span class="arithmatex">\(L_1(C) = \sum_i \log P(u_i | u_{i-k}, ... , u_{i-1}; \theta)\)</span>. Die Optimierung erfolgt durch das <em>unsupervised Learning</em> mit dem Ziel, die Wahrscheinlichkeit der nächsten Token zu maximieren.</p>
<p>Um bessere und natürlichere Ergebnisse zu erhalten, werden zukünftige GPT-Modelle mit <em>sample</em> Algorithmen erweitert, damit die Ausgaben im Wortlaut varrieren und nicht immer die gleichen Texte generiert werden.</p>
<ol>
<li>
<p><strong>Top-K-Verfahren</strong>: Die Wahrscheinlichkeiten der Tokens werden sortiert und <em>k</em> Tokens mit der höchsten Wahrscheinlichkeit werden ausgewählt. Von denen wird dann zufällig ein Token ausgewählt, welches dann als nächstes Token verwendet wird.</p>
</li>
<li>
<p><strong>Nucleus</strong>: Dieses Verfahren funktioniert ähnlich zu Top-K, jedoch wird hier nicht eine feste Anzahl von Tokens ausgewählt, sondern die Tokens werden solange ausgewählt, bis die Summe der Wahrscheinlichkeiten der ausgewählten Tokens einen bestimmten Wert überschreitet. Dieser Wert wird als <em>p</em> bezeichnet und ist ein Hyperparameter des Modells.</p>
</li>
<li>
<p><strong>Temperature</strong>: Dieses Verfahren wird verwendet, um die Wahrscheinlichkeiten der Tokens zu verändern. Die Wahrscheinlichkeiten werden durch die Temperatur <em>T</em> geteilt. Je höher die Temperatur, desto höher ist die Wahrscheinlichkeit, dass ein Token mit einer niedrigen Wahrscheinlichkeit ausgewählt wird. Bei einer niedrigen Temperatur werden die Wahrscheinlichkeiten der Tokens erhöht, die bereits eine hohe Wahrscheinlichkeit haben. Die Formell hierfür lautet: <span class="arithmatex">\(\text{softmax}(z_i) = \frac{e^{z_i/T}}{\sum_j e^{z_j/T}}\)</span></p>
</li>
<li>
<p><strong>Greedy-Verfahren</strong>: Dieses Verfahren wählt immer das Token mit der höchsten Wahrscheinlichkeit aus.</p>
</li>
<li>
<p><strong>Beam Search</strong>: Dieses Verfahren wählt die <em>k</em> wahrscheinlichsten Tokens aus und erzeugt für jedes Token eine neue Sequenz. Diese Sequenzen werden dann wiederum durch die Wahrscheinlichkeiten der nächsten Tokens erweitert. Dieser Vorgang wird solange wiederholt, bis die Sequenzen eine bestimmte Länge - <em>beam size</em> - erreicht haben. Die Sequenz mit der höchsten Wahrscheinlichkeit wird dann als Ausgabe verwendet.</p>
</li>
</ol>
<p>Aktuell verwendet OpenAI das nucleus-Verfahren und das Temperaturverfahren, um die Textgenerierung zu verbessern.</p>
<h4 id="252-fine-tuning">2.5.2 Fine-Tuning</h4>
<p>Im Fine-Tuning muss das Modelle verschiedene Aufgaben erkennen können und diese dann lösen. Dafür wird das Modell mit einem Datensatz trainiert, der aus einer großen Menge von Texten besteht, die mit den jeweiligen Aufgaben verknüpft sind. Die Aufgaben können beispielsweise darin bestehen, dass das Modell Texte vervollständigen, Fragen beantworten oder Texte klassifizieren muss.
Foglich gibt es ein Label <span class="arithmatex">\(y\)</span> und ein zugehörige Sequenz an Tokens <span class="arithmatex">\(x^1, \dots , x^m\)</span>. Um die Wahrscheinlichkeit für das Label <span class="arithmatex">\(y\)</span> zu berechnen, werden die Aktivierungen des Modelles und die Ausgabematrix benötigt.</p>
<div class="arithmatex">\[ P(y|x^1, \dots , x^m) = \text{softmax}(h_l^mW_y) \]</div>
<p>Somit ergibt sich ein neues Ziel, das optimiert werden muss, um die Parameter optimal einzustellen: <span class="arithmatex">\(L_2(D) = \sum_{(x,y) \in D} \log P(y|x^1, \dots , x^m)\)</span>. Die Optimierung erfolgt durch das <em>supervised Learning</em> mit dem Ziel, die Wahrscheinlichkeit des Labels <span class="arithmatex">\(y\)</span> zu maximieren.</p>
<p>Insgesamt kann man das pre-trained Sprachmodell beim fine-tuning mitverwenden, damit die Generalisierung verbessert wird und die Konvergenz beschleunigt wird.</p>
<div class="arithmatex">\[ L_3(D) = L_2(D) + \lambda L_1(D) \]</div>
<h4 id="253-reward-model">2.5.3 Reward Model</h4>
<p>Das Reward Model basiert auf dem Likert-Scale, der verwendet wird, um die menschlichen Bewertungen der Plausibilität der GPT-Ausgaben zu erfassen. Hierbei werden die generierten Texte von einem Menschen auf einer Skala von 1 bis 7 bewertet. Diese Skala ermöglicht es, die Qualität und die Plausibilität der Texte abzubilden, wobei eine höhere Zahl eine bessere Bewertung darstellt. Zusätzlich zur Likert-Skala wird der Mensch auch dazu aufgefordert, ja-nein Fragen zu beantworten, um zu erklären, warum er die bestimmte Bewertung abgegeben hat. Dieses zusätzliche Feedback ermöglicht es, Einblicke in die Entscheidungsfindung des Bewerters zu erhalten und zu verstehen, welche spezifischen Aspekte des Textes zur Bewertung beigetragen haben. Auf Grundlage dieser menschlichen Bewertungen entsteht ein umfangreicher Datensatz, der verwendet wird, um ein kleineres GPT-Modell zu trainieren. Dieses kleinere Modell besitzt in der Regel rund 6 Milliarden Parameter und wird speziell für die Aufgabe der Textbewertung eingesetzt. Das trainierte kleinere GPT-Modell wird anschließend eingesetzt, um die Ausgaben des großen GPT-Modells zu bewerten. Es analysiert die generierten Texte und weist ihnen eine Bewertung zu, die auf den erlernten Kriterien basiert. Diese Bewertung dient dann als Rückmeldung für das große GPT-Modell, um seine Textgenerierung kontinuierlich zu verbessern. Indem das kleinere GPT-Modell die Textausgaben des großen Modells bewertet, wird ein iterativer Feedback-Loop geschaffen. Das große Modell kann durch das erhaltene Feedback lernen und seine Textgenerierungsfähigkeiten entsprechend optimieren, um qualitativ hochwertigere und plausiblere Texte zu erzeugen.</p>
<div class="arithmatex">\[ loss(\theta) = - \frac{1}{\binom{K}{2}} E_{(x, y_w, y_l) \sim D}[\log(\sigma(r_{\theta}(x, y_w) - r_{\theta}(x, y_l)))] \]</div>
<ul>
<li><span class="arithmatex">\(D\)</span>: Datensatz mit den menschlichen Bewertungen</li>
<li><span class="arithmatex">\(K\)</span>: Anzahl der Antworten von GPT-Modell</li>
<li><span class="arithmatex">\(x\)</span>: Eingabesquenz</li>
<li><span class="arithmatex">\(y_w\)</span>: präfferierte Ausgabe von GPT</li>
<li><span class="arithmatex">\(y_l\)</span>: Ausgabe von GPT</li>
<li><span class="arithmatex">\(r_{\theta}\)</span>: Skalar zum Reward-Modell zu den Parametern <span class="arithmatex">\(\theta\)</span></li>
<li><span class="arithmatex">\(\sigma\)</span>: Sigmoid-Funktion</li>
</ul>
<p>Die Hauptidee ist, wenn die präferierte Ausgabe <span class="arithmatex">\(y_w\)</span> eine höhere Bewertung als die Ausgabe <span class="arithmatex">\(y_l\)</span> erhält, dann wird der Verlust minimiert. Wenn die Ausgabe <span class="arithmatex">\(y_l\)</span> eine höhere Bewertung als die präferierte Ausgabe <span class="arithmatex">\(y_w\)</span> erhält, dann wird der Verlust maximiert. Die Sigmoid-Funktion wird verwendet, um die Wahrscheinlichkeit zu berechnen, dass die präferierte Ausgabe <span class="arithmatex">\(y_w\)</span> eine höhere Bewertung als die Ausgabe <span class="arithmatex">\(y_l\)</span> erhält. Die Sigmoid-Funktion ist definiert als <span class="arithmatex">\(\sigma(x) = \frac{1}{1 + e^{-x}}\)</span>. Die Sigmoid-Funktion ist eine monoton steigende Funktion, die Werte zwischen 0 und 1 zurückgibt. Wenn die Differenz zwischen den Bewertungen <span class="arithmatex">\(r_{\theta}(x, y_w)\)</span> und <span class="arithmatex">\(r_{\theta}(x, y_l)\)</span> groß ist, dann ist die Wahrscheinlichkeit, dass die präferierte Ausgabe <span class="arithmatex">\(y_w\)</span> eine höhere Bewertung als die Ausgabe <span class="arithmatex">\(y_l\)</span> erhält, nahe 1. Wenn die Differenz zwischen den Bewertungen <span class="arithmatex">\(r_{\theta}(x, y_w)\)</span> und <span class="arithmatex">\(r_{\theta}(x, y_l)\)</span> klein ist, dann ist die Wahrscheinlichkeit, dass die präferierte Ausgabe <span class="arithmatex">\(y_w\)</span> eine höhere Bewertung als die Ausgabe <span class="arithmatex">\(y_l\)</span> erhält, nahe 0. Der Logarithmus steigert das Verhalten der Sigmoidfunktion ins negative und ermöglicht die Berechnung des Verlustes, da er für kleine Werte nahe 0 nach <span class="arithmatex">\(- \infty\)</span> anstrebt und bei 1 seine Nullstelle hat.</p>
<figure>
<p><img alt="GPT3" src="../img/llms/GPT3.png" width="600" />
  </p>
<figcaption>Fig. Reward Model with Sigmoid &amp; Logarithm </figcaption>
</figure>
<h4 id="254-reinforcement-learning">2.5.4 Reinforcement Learning</h4>
<figure>
<p><img alt="GPT7" src="../img/llms/GPT7.png" width="800" />
  </p>
<figcaption>Fig. Reinforcement Learning </figcaption>
</figure>
<p>Reinforcement Learning (RL) ist eine Methode des maschinellen Lernens, bei der ein Agent in einer Umgebung agiert und durch Interaktion mit dieser Umgebung lernen kann, welche Aktionen zu belohnenden Ergebnissen führen. Das Ziel des RL besteht darin, eine optimale Handlungsstrategie zu erlernen, um maximale Belohnungen zu erhalten. Der RL-Prozess besteht aus mehreren Iterationen, in denen der Agent versucht, seine Handlungsstrategie zu verbessern. Dies geschieht durch das Lernen aus Erfahrung, indem der Agent wiederholt Aktionen ausführt, den Zustand der Umgebung wahrnimmt und Belohnungen erhält. Der Agent verwendet dann Algorithmen des maschinellen Lernens, um eine Strategie zu entwickeln, die die erwarteten Belohnungen maximiert.</p>
<p>Dieser Prozess baut auf folgenden Gleichungen auf:</p>
<p><em>Markov Decision Process (MDP)</em>:</p>
<table>
<thead>
<tr>
<th>Gleichungen</th>
<th>Symbole</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(M = (S, A, P, R, \gamma)\)</span></td>
<td><span class="arithmatex">\(S\)</span>: Zustandsraum</td>
</tr>
<tr>
<td>Markov Chain: <span class="arithmatex">\(P_a(s, s')= \frac{P(s', s, a)}{P(s, a)}\)</span></td>
<td><span class="arithmatex">\(A\)</span>: Aktionen</td>
</tr>
<tr>
<td><span class="arithmatex">\(R: (S × A)\)</span></td>
<td><span class="arithmatex">\(P\)</span>: Übergangsfunktion</td>
</tr>
<tr>
<td><span class="arithmatex">\(\pi: S \to A\)</span></td>
<td><span class="arithmatex">\(R\)</span>: Belohnungsfunktion</td>
</tr>
<tr>
<td><span class="arithmatex">\(E_{\pi, p}[\sum_{t=0}^{\infty} \gamma^t R(s_t, \pi(s_t))]\)</span></td>
<td><span class="arithmatex">\(\gamma\)</span>: Diskontierungsfaktor</td>
</tr>
<tr>
<td><span class="arithmatex">\(0 \le \gamma \le 1\)</span></td>
<td><span class="arithmatex">\(\pi\)</span>: Strategie des Agenten</td>
</tr>
</tbody>
</table>
<p><em>Wertefunktion</em>:</p>
<p>Kalkuliert den erwarteten kumulativen Gewinn einer Aktion in einem Zustand</p>
<table>
<thead>
<tr>
<th>Gleichungen</th>
<th>Symbole</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(V^{\pi}(s_t) = E_{\pi, p}[\sum_{k=0}^{\infty} \gamma^k R(s_{t+k}, \pi(s_{t+k}))]\)</span></td>
<td><span class="arithmatex">\(V^{\pi}(s_t)\)</span>: Wertefunktion</td>
</tr>
<tr>
<td><span class="arithmatex">\(Q^{\pi}(s_t, a_t) = R(s_t, a_t) + V^{\pi}(s_t)_{k=1}\)</span></td>
<td><span class="arithmatex">\(Q^{\pi}(s_t, a_t)\)</span>: Aktionenwertefunktion</td>
</tr>
</tbody>
</table>
<p><em>Bellman Gleichung</em>:</p>
<table>
<thead>
<tr>
<th>Gleichungen</th>
<th>Symbole</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(V^{\pi}(s_t) = E_{\pi, p}[R(s_t, \pi(s_t)) + \gamma V^{\pi}(s_{t+1})]\)</span></td>
<td><span class="arithmatex">\(V^{\pi}(s_t)\)</span>: Wertefunktion</td>
</tr>
<tr>
<td><span class="arithmatex">\(Q^{\pi}(s_t, a_t) = E_{\pi, p}[R(s_t, a_t) + \gamma Q^{\pi}(s_{t+1}, \pi(s_{t+1}))]\)</span></td>
<td><span class="arithmatex">\(Q^{\pi}(s_t, a_t)\)</span>: Aktionenwertefunktion</td>
</tr>
<tr>
<td><span class="arithmatex">\(\pi^*(s) = \text{argmax}_{a \in A}(\max_{\pi}Q^{\pi}(s, a))\)</span></td>
<td><span class="arithmatex">\(\pi^*\)</span>: otimale Strategie des Agenten</td>
</tr>
</tbody>
</table>
<p><em>Policy</em>:</p>
<p>Die Policy ist die Strategie des Agenten, die angibt, welche Aktionen in einem bestimmten Zustand ausgeführt werden sollen. Die Policy kann deterministisch oder stochastisch sein.</p>
<table>
<thead>
<tr>
<th>Gleichungen</th>
<th>Symbole</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="arithmatex">\(\pi_{k+1}(s) = \text{argmax}_aQ^{\pi_k}(s, a)\)</span></td>
<td><span class="arithmatex">\(\pi(s_t)\)</span>: Policy</td>
</tr>
</tbody>
</table>
<p>Aus diesen vier Grundgleichungen entstehen folgende Algorithmen:</p>
<ul>
<li>
<p>Die Hauptidee des <em>Q-Learning</em> besteht darin, mithilfe einer Q-Funktion die optimale Handlungsstrategie eines Agenten in einer Umgebung zu erlernen. Die Q-Funktion gibt den erwarteten Nutzen (Q-Wert) einer Aktion in einem gegebenen Zustand an. Durch das Lernen und Aktualisieren der Q-Werte während des Lernprozesses kann der Agent die beste Aktion in jedem Zustand auswählen und so die Gesamtbelohnung maximieren.</p>
</li>
<li>
<p><em>Deep Q - Learning</em> (DQL) ist eine Erweiterung des klassischen Q-Learning-Algorithmus, der tiefe neuronale Netzwerke verwendet, um komplexe Zustandsräume zu modellieren und eine optimale Handlungsstrategie zu erlernen. Durch die Integration von Deep Learning-Techniken ermöglicht DQL den Agenten, in hochdimensionalen Umgebungen mit großen Zustands- und Aktionsräumen effektiv zu operieren.</p>
</li>
<li>
<p><em>REINFORCE</em> ist ein Algorithmus des Reinforcement Learning, der zur Lösung von Aufgaben des verstärkenden Lernens eingesetzt wird. Er basiert auf der Idee, Richtlinien (Policies) zu erlernen, die einem Agenten ermöglichen, eine optimale Handlungsstrategie in einer gegebenen Umgebung zu entwickeln. Der REINFORCE-Algorithmus verwendet Monte Carlo-Sampling, um die Richtlinie zu verbessern, indem er die Gesamtbelohnung der durchgeführten Aktionen maximiert.</p>
</li>
<li>
<p><strong>Proximal Policy Optimization (PPO)</strong> wird in den GPT-Nachfolgern verwendet. PPO zielt darauf ab, die Vorzüge von Policy Gradient-Methoden und Trust Region Policy Optimization (TRPO) zu kombinieren, um ein effizientes und stabiles Lernen zu ermöglichen und bestmögliche Policies für den Agenten zu finden.</p>
</li>
</ul>
<p>Allgemein ist PPO eine <em>stochastic gradient ascent</em> Methode, um das bestmögliche Ergebnis zu erreichen. Dabei wird die optimale Policy mit einem Gradientenverfahren gesucht, indem eine Policy zu einem Zeitpunkt <span class="arithmatex">\(t\)</span> mit der Vorteilsfunktion an dieser Stelle verrechnet wird. Die Standardformel hierfür ist:</p>
<div class="arithmatex">\[ \hat{g} = \frac{1}{T} \sum_{t=1}^{T} \nabla_{\theta} \log \pi_{\theta}(a_t|s_t) A^{\pi_{\theta}}(s_t, a_t) \]</div>
<p>Um die Policy zu verbessern, wird ein sogenanntes <em>surrogate objective</em> verwendet. Dieses ist eine Funktion, die die Policy verbessert, ohne sie zu stark zu verändern. Es basiert auf dem Ansatz der <em>trust region</em>, der die Änderung der Policy begrenzt, indem er die Divergenz zwischen der alten und der neuen Policy begrenzt. Dies wird erreicht, indem die Veränderungen der Policy mit einem Faktor <span class="arithmatex">\(\epsilon\)</span> geklippt werden. Die Verlustfunktion, die für dieses Ziel verwendet wird, lautet:</p>
<div class="arithmatex">\[ L^{CLIP}(\theta) = \hat{E}_t [min(r_t(\theta) \hat{A}_t, clip(r_t(\theta), 1 - \epsilon, 1 + \epsilon) \hat{A}_t)]; \]</div>
<div class="arithmatex">\[ r_t(\theta)=\frac{\pi_{\theta}(a_t, s_t)}{\pi_{\theta_{old}}(a_t, s_t)} \]</div>
<p>Hierbei steht <span class="arithmatex">\(\theta\)</span> für die Parameter der Policy, <span class="arithmatex">\(E_t\)</span> repräsentiert die erwartete Wertung über den Zeitpunkt <span class="arithmatex">\(t\)</span>, <span class="arithmatex">\(r_t(\theta)\)</span> ist das Verhältnis zwischen den Wahrscheinlichkeiten der aktuellen Policy und der alten Policy für eine bestimmte Aktion im Zustand <span class="arithmatex">\(s_t\)</span>, <span class="arithmatex">\(A_t\)</span> ist der Vorteil (Advantage) der Aktion und clip ist eine Funktion, die den Wert <span class="arithmatex">\(r_t(\theta)\)</span> innerhalb eines bestimmten Intervalls einschränkt.</p>
<p>Die Verlustfunktion <span class="arithmatex">\(L_clip(\theta)\)</span> vergleicht die Aktionen der aktuellen Policy mit denen der alten Policy und berücksichtigt dabei den Vorteil der Aktionen. Sie sorgt dafür, dass die Änderungen der Policy begrenzt bleiben und die Divergenz zwischen der alten und der neuen Policy kontrolliert wird. Die Klippfunktion im Ausdruck <span class="arithmatex">\(\text{clip}(r_t(\theta), 1 - \epsilon, 1 + \epsilon)\)</span> stellt sicher, dass das Verhältnis <span class="arithmatex">\(r_t(\theta)\)</span> innerhalb des Intervalls <span class="arithmatex">\([1 - \epsilon, 1 + \epsilon]\)</span> bleibt.</p>
<p>Durch die Verwendung dieses <em>surrogate objectives</em> in Kombination mit der <em>trust region</em> wird sichergestellt, dass die Policy allmählich verbessert wird, ohne dass sie zu stark von der alten Policy abweicht. Dies trägt zur Stabilität des Lernprozesses bei und ermöglicht eine kontrollierte Anpassung der Policy, um bessere Ergebnisse zu erzielen.</p>
<p>Bei der PPO-Funktion von GPT wird die Verlustfunktion <span class="arithmatex">\(L^{CLIP}(\theta)\)</span> mit einem Faktor <span class="arithmatex">\(\lambda\)</span> gewichtet, um die Veränderung der Policy zu begrenzen. Die PPO - Funktion lautet:</p>
<div class="arithmatex">\[ \text{objective}(\phi) = E_{(x, y) \sim D_{\phi}^{RL}} [r_{\theta}(x, y) - \beta \log(\pi_{\phi}^{RL}(y | x) / \pi^{SFT}(y | x))] + \gamma * E_{x \sim D_{pretrain}} [ log(\pi_{\phi}^{RL}(x))] \]</div>
<ul>
<li>
<p><span class="arithmatex">\(E\)</span>: Erwartungswert</p>
</li>
<li>
<p><span class="arithmatex">\(x, y\)</span>: Eingabe- und Ausgabedatenpaare</p>
</li>
<li>
<p><span class="arithmatex">\(D_{\phi}^{RL}\)</span>: Datenverteilung, die durch die RL-Policy <span class="arithmatex">\(\pi^{RL}\)</span> bestimmt wird</p>
</li>
<li>
<p><span class="arithmatex">\(r_{\theta}(x, y)\)</span>: Rückgabewert (Reward) für das Datenpaar <span class="arithmatex">\((x, y)\)</span> unter den aktuellen Parametern <span class="arithmatex">\(\theta\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(\beta\)</span>: Ein Gewichtungsfaktor für die Regularisierung des Rewards</p>
</li>
<li>
<p><span class="arithmatex">\(\pi_{\phi}^{RL}(y | x)\)</span>: Wahrscheinlichkeit der Ausgabe y gegeben der Eingabe x unter der RL-Policy <span class="arithmatex">\(\pi^{RL}\)</span> mit den Parametern <span class="arithmatex">\(\phi\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(\pi^{SFT}(y | x)\)</span>: Wahrscheinlichkeit der Ausgabe y gegeben der Eingabe x von dem fine-tuning-Modell</p>
</li>
<li>
<p><span class="arithmatex">\(\gamma\)</span>: Ein Gewichtungsfaktor für den Pretraining-Term (normal <span class="arithmatex">\(\gamma=0\)</span> für PPO)</p>
</li>
<li>
<p><span class="arithmatex">\(D{pretrain}\)</span>: Datenverteilung für das Pretraining</p>
</li>
<li>
<p><span class="arithmatex">\(\pi_{\phi}^{RL}(x)\)</span>: Wahrscheinlichkeit der Eingabe x unter der RL-Policy <span class="arithmatex">\(\pi^{RL}\)</span> mit den Parametern <span class="arithmatex">\(\phi\)</span></p>
</li>
</ul>
<figure>
<p><img alt="GPT6" src="../img/llms/GPT6.png" width="600" />
  </p>
<figcaption>Fig. GPT full learning cycle </figcaption>
</figure>
<h3 id="26-meta-learning">2.6 Meta-Learning</h3>
<hr />
<p>Meta-Learning ist ein Ansatz im maschinellen Lernen, bei dem Modelle trainiert werden, um aus Erfahrungen zu lernen und dieses Wissen auf neue, ähnliche Aufgaben anzuwenden. Es ermöglicht schnelles und effizientes Lernen mit begrenzten Trainingsdaten und Anpassung an neue Situationen. Es gibt viel versschiedene Arten von Meta-Learning, wie z.B. Zero-Shot Learning, One-Shot Learning und Few-Shot Learning. Andere Ansätze beinhalten einen <em>Meta Learner</em>, der schwächere Modelle rauswirft und die Anpassungsfähigkeiten der restlichen Modelle zu verbessern. Im folgenden wird auf die <em>shot-learning Ansätze</em> eingegangen.</p>
<p>Ziel der Shot-Learning Methoden ist es das Modell robuster gegen Unbekanntes machen, indem neue Klassen, Beziehungen oder Embeddings hinzugefügt werden. Das Modell soll in der Lage sein, neue Klassen zu erkennen, die es noch nie gesehen hat und mit ihnen umgehenzu können. Es werden keine Parameterupdates durchgeführt während der Inferenzzeit (Vorhersagen).</p>
<h4 id="261-zero-shot-learning">2.6.1 Zero-Shot Learning</h4>
<figure>
<p><img alt="ML" src="../img/llms/MetaLearning.png" width="400" />
  </p>
<figcaption>Fig. Zero-Shot Learning </figcaption>
</figure>
<p>Das Zero-Shot Learning wird als unfair angesehen, da der Transformer nur durch die Aufgabenbeschreibung für einen Input die richtige Antwort vorhersagen muss. Folglich muss das Modell die Aufgabenbeschreibung verstehen und die richtige Antwort vorhersagen.</p>
<h4 id="262-one-shot-learning">2.6.2 One-Shot Learning</h4>
<figure>
<p><img alt="ML2" src="../img/llms/MetaLearning2.png" width="400" />
  </p>
<figcaption>Fig. One-Shot Learning </figcaption>
</figure>
<p>Beim One-Shot Learning wird das Modell mit einem zusätzlichen Beispiel zu der Zero-Shot Methode trainiert und muss dann die richtige Antwort vorhersagen. Das Modell soll in der Lage sein, die Beziehung zwischen Beispiel, Aufgabe und der Antwort zu verstehen.</p>
<h4 id="263-few-shot-learning">2.6.3 Few-Shot Learning</h4>
<figure>
<p><img alt="ML3" src="../img/llms/MetaLearning3.png" width="400" />
  </p>
<figcaption>Fig. Few-Shot Learning </figcaption>
</figure>
<p>Das Few-Shot Learning ist eine Erweiterung des One-Shot Learning, indem mehrere Beispiele zu der Aufgabe hinzugefügt werden. Es wird vorgeschlage zwischen 10 und 100 Beispiele zu verwenden.</p>
<h3 id="27-benchmarking">2.7 Benchmarking</h3>
<hr />
<figure>
<p><img alt="Benchmarks" src="../img/llms/Benchmarks.png" width="600" />
  </p>
<figcaption>Fig. Benchmarks </figcaption>
</figure>
<h4 id="271-glue">2.7.1 GLUE</h4>
<p>GLUE steht für <em>General Language Understanding Evaluation</em> und ist ein Benchmark-Datensatz für die Evaluation von Modellen zur Sprachverarbeitung und zum Textverständnis. Der Datensatz besteht aus 9 verschiedenen Aufgaben, die jeweils eine andere Art von Sprachverständnis erfordern. Die Aufgaben sind wie folgt:</p>
<ol>
<li>
<p><strong>CoLA</strong> - <em>Corpus of Linguistic Acceptability</em>: Aufgabe zur binären Klassifikation, bei der die Akzeptanz grammatischer Sätze bestimmt werden soll.</p>
</li>
<li>
<p><strong>SST-2</strong> - <em>Stanford Sentiment Treebank</em>: Aufgabe zur binären Klassifikation, bei der die Sentiment-Klassifizierung von Sätzen gefordert wird.</p>
</li>
<li>
<p><strong>MRPC</strong> - <em>Microsoft Research Paraphrase Corpus</em>: Aufgabe zur Bestimmung der semantischen Ähnlichkeit zwischen Sätzen durch die Erkennung von Paraphrasen.</p>
</li>
<li>
<p><strong>QQP</strong> - <em>Quora Question Pairs</em>: Aufgabe zur Erkennung von Paraphrasen, bei der die Ähnlichkeit von Fragepaaren beurteilt werden soll.</p>
</li>
<li>
<p><strong>STS-B</strong> - <em>Semantic Textual Similarity Benchmark</em>: Aufgabe zur Berechnung der semantischen Ähnlichkeit zwischen Sätzen anhand von kontinuierlichen Wertungen.</p>
</li>
<li>
<p><strong>MNLI</strong> - <em>Multi-Genre Natural Language Inference</em>: Aufgabe zur Überprüfung der Textual Entailment-Fähigkeiten, bei der die logische Beziehung zwischen Satzpaaren bestimmt werden soll.</p>
</li>
<li>
<p><strong>QNLI</strong> - <em>Question Natural Language Inference</em>: Aufgabe zur Textual Entailment-Bestimmung basierend auf Fragen und Antworttexten.</p>
</li>
<li>
<p><strong>RTE</strong> - <em>Recognizing Textual Entailment</em>: Aufgabe zur Bestimmung der Textual Entailment-Beziehung zwischen Sätzen.</p>
</li>
<li>
<p><strong>WNLI</strong> - <em>Winograd Schema Challenge</em>: Aufgabe zur maschinellen Resolution von referenziellen Ausdrücken in einer Frage-Antwort-Form.</p>
</li>
</ol>
<h4 id="272-superglue">2.7.2 SuperGLUE</h4>
<p>SuperGLUE steht für "Super General Language Understanding Evaluation" und ist eine Weiterentwicklung des GLUE-Benchmarks. Während GLUE neun Aufgaben zur Bewertung von Modellen zur Sprachverarbeitung umfasst, erweitert SuperGLUE den Benchmark um zusätzliche und anspruchsvollere Aufgaben, um die Leistung von Modellen für Sprachverständnis und Textverarbeitung weiter zu testen. SuperGLUE umfasst insgesamt acht Aufgaben, die komplexere Sprachverständnisfähigkeiten erfordern. Die Aufgaben sind:</p>
<ol>
<li>
<p><strong>BoolQ</strong> - <em>Boolean Questions</em>: Aufgabe zur Beantwortung von Ja/Nein-Fragen auf der Grundlage eines gegebenen Kontexts.</p>
</li>
<li>
<p><strong>CB</strong> - <em>CommitmentBank</em>: Aufgabe zur Bestimmung der semantischen Implikation zwischen zwei Sätzen.</p>
</li>
<li>
<p><strong>COPA</strong> - <em>Choice of Plausible Alternatives</em>: Aufgabe zur Kausalitätsbeurteilung, bei der aus zwei möglichen Ursachen die plausiblere ausgewählt werden soll.</p>
</li>
<li>
<p><strong>MultiRC</strong> - <em>Multi-Sentence Reading Comprehension</em>: Aufgabe zum Leseverständnis mehrerer Sätze, bei der mehrere Fragen zu einem gegebenen Text beantwortet werden müssen.</p>
</li>
<li>
<p><strong>ReCoRD</strong> - <em>Reading Comprehension with Commonsense Reasoning Dataset</em>: Aufgabe zum Leseverständnis mit "Commonsense" -Reasoning, bei der fehlende Informationen in einem gegebenen Text ergänzt werden müssen.</p>
</li>
<li>
<p><strong>RTE</strong> - <em>Recognizing Textual Entailment</em>: Ähnlich wie im GLUE-Benchmark ist diese Aufgabe darauf ausgerichtet, die Textual Entailment-Beziehung zwischen Sätzen zu bestimmen.</p>
</li>
<li>
<p><strong>WiC</strong> - <em>Word-in-Context</em>: Aufgabe zur Beurteilung der Bedeutung eines Wortes in verschiedenen Kontexten.</p>
</li>
<li>
<p><strong>WSC</strong> - <em>Winograd Schema Challenge</em>: Ähnlich wie im GLUE-Benchmark ist dies eine Aufgabe zur maschinellen Resolution von referenziellen Ausdrücken in einer Frage-Antwort-Form.</p>
</li>
</ol>
<h4 id="273-squad">2.7.3 SQuAD</h4>
<p>SQuAD steht für "Stanford Question Answering Dataset" und ist ein bekannter Benchmark-Datensatz für maschinelles Lesen und Frage-Antwort-Aufgaben. Der SQuAD-Datensatz besteht aus einer umfangreichen Sammlung von Frage-Antwort-Paaren, die auf Textpassagen aus Wikipedia-Artikeln basieren. Die Besonderheit von SQuAD besteht darin, dass die Fragen im Kontext des Textes gestellt werden, d.h., die Antworten auf die Fragen können direkt aus dem gegebenen Text extrahiert werden, ohne externe Quellen zu konsultieren. Dies macht SQuAD zu einer herausfordernden Aufgabe für maschinelles Lesen und Textverständnis.</p>
<h4 id="274-modelle">2.7.4 Modelle</h4>
<figure>
<p><img alt="Modelle" src="../img/llms/Modelle.png" width="600" />
  </p>
<figcaption>Fig. Modelle </figcaption>
</figure>
<h2 id="3-anwendungen">3 Anwendungen</h2>
<h3 id="31-limitationen-heutiger-large-language-models">3.1 Limitationen heutiger Large Language Models</h3>
<p>Mit dem Aufstieg von Large Language Model wie OpenAI's ChatGPT erleben wir eine Revolution im Bereich der automatischen Generierung von Inhalten. Aber wie mit jeder Technologie haben auch solch mächtige Modelle Probleme und Limitationen. In diesem Gebiet können wir 2 Hauptprobleme ausmachen.</p>
<p>Das erste bezieht sich auf das sogenannte "Knowledge Cutoff". Wer kennt diese Situation nicht? Man stellt ChatGPT eine Frage und als Antwort bekommt man dann im ersten Abschnitt (auf Deutsch übersetzt): "Nach meinem derzeitigen Wissenstand bis September 2021...". Dieses Problem macht es uns extrem schwer neue Ereignisse zu erfassen, auszuwerten und als Transferwissen in unsere erstellten Inhalte einzubinden.</p>
<p>Im zweiten Problem sehen wir, dass sich dies allerdings nicht nur auf Inhalte, die nach dem letzten Trainingszyklus erstellt wurden, bezieht, sondern auch auf Daten die gar nicht erst in das Trainingsset mit eingeflossen sind. Gehen wir davon aus, dass man zum Beispiel Fragen zu privaten Dokumenten stellen möchte, um entweder einen Überblick zu bekommen oder deren Richtigkeit zu prüfen.
Vielleicht sind Sie Teil einer Firma die mit ihrem neusten Produkt eine Werbekampagne starten möchte und ChatGPT für die beste Ausführung das Fachwissen zu diesem benötigt. Oder Sie möchten auf bestimmte E-Mails automatisch antworten und ausgemachte Termine in Ihren Kalender übertragen.</p>
<p>Die denkbaren Möglichkeiten auf diesem Gebiet sind fast unbegrenzt, dennoch ist dies nicht mit der Implementation des Standardprodukts <em>ChatGPT</em> machbar, oder vielleicht doch?...</p>
<h3 id="32-die-losung-langchain">3.2 Die Lösung: <a href="https://python.langchain.com/en/latest/index.html">LangChain</a></h3>
<p>Die beschriebenen Limitationen scheinen ein sehr komplexes Problem aufzuwerfen, aber wie so oft wird dadurch nur die Tür für innovative Lösungen aufgemacht. Das ist der Punkt an dem <a href="https://python.langchain.com/en/latest/index.html">LangChain</a> ins Spiel kommt.</p>
<p>Man kann es sich wie ein Schweizer Taschenmesser vorstellen, dass nur darauf ausgelegt ist, das bauen von Applikationen mit Large Language Models zu vereinfachen. Dabei agiert es wie eine Art <em>Mittelschicht</em> zwischen LLM und anderen Tools.</p>
<p>Mit LangChain ist es uns möglich aufgrund von Nutzeranfragen aktuelle Daten zu googeln, private Dateien auszuwerten, mathematische Formeln zu berechnen, Code zu erstellen und auszuführen und noch vieles mehr.
Diese genannten Punkte sind schon sehr beindruckend, aber das mit Abstand mächtigste Feature, und auch das simpelste, ist dann man die Ausgabe von einer Antwort als Eingabe für den nächsten benutzen kann. Das bedeutet, dass ChatGPT sich selbst Feedback zu den erledigten Aufgaben geben kann und seine aktuelle Lösung darauf basierend verbessern kann. Außerdem kann man selbst festlegen, welche Teile der vorherigen Aufgaben in die neue Eingabe mit eingehen sollen. Eine solch simple Technik is wirklich faszinierend und ihre Möglichkeiten können wir am Projekt <a href="https://github.com/Significant-Gravitas/Auto-GPT">AutoGPT</a> bewundern.</p>
<p>Mit diesem Gedanken wollen wir jetzt ein Szenario definieren, welches eine Einführung in die erwähnten Möglichkeiten gibt. Ein gutes Beispiel ist die Erstellung eines Podcast Skripts welche die neusten Entwicklungen im Bereich der Large Language Models beleuchten soll. Außerdem wollen wir die Anforderungen, welche in den Vorlesungsskript für diese Aufgabe gegeben worden sind miteinbeziehen.</p>
<p>Diese Aufgabe können wir somit in 3 Schritte unterteilen:</p>
<ol>
<li>Die Anforderungen für den Podcast auf dem Vorlesungsskript extrahieren</li>
<li>Nachforschungen zu den aktuellsten Themen in diesem Gebiet recherchieren</li>
<li>Mithilfe der Anforderungen und Recherchen unser Podcast Skript generieren</li>
</ol>
<h3 id="33-code-demo-der-allwissende-podcast-schreiber">3.3 Code Demo: Der allwissende Podcast Schreiber</h3>
<p>Um ein möglichst gutes Ergebnis zu erzielen benutzen wir zu erstellen des Skripts ChatGPT, Model <em>GPT3.5-turbo</em>. Um Zugriff auf Antworten des Modells in LangChain zu erreichen müssen wir einen sogenannten <em>API Token</em> erstellen und angeben.</p>
<blockquote>
<p>APIs sind häufig zahlungspflichtig. Die genauen Kosten sollte man auf der <a href="https://platform.openai.com/">OpenAI Website</a> recherchieren.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">llm</span> <span class="o">=</span> <span class="n">OpenAI</span><span class="p">(</span><span class="n">openai_api_key</span><span class="o">=</span><span class="n">openai_api_key</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
<span class="n">topic</span> <span class="o">=</span> <span class="s1">&#39;Large Language Models&#39;</span>
</code></pre></div>
<p>Damit können wir unser <code>llm</code> initialisieren und geben mit dem Temperaturwert an, dass wir kreative Antworten erhalten wollen. Außerdem geben wir an, zu welchem Thema ein Podcast erstellt werden soll.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># document loaders</span>
<span class="n">loader</span> <span class="o">=</span> <span class="n">TextLoader</span><span class="p">(</span><span class="n">file_path</span><span class="o">=</span><span class="s1">&#39;../documents/VL1-1-processed-eng.txt&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="n">document_content</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
<span class="n">text_splitter</span> <span class="o">=</span> <span class="n">CharacterTextSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">split_content</span> <span class="o">=</span> <span class="n">text_splitter</span><span class="o">.</span><span class="n">split_documents</span><span class="p">(</span><span class="n">document_content</span><span class="p">)</span>

<span class="c1"># create embeddings</span>
<span class="n">embeddings</span> <span class="o">=</span> <span class="n">OpenAIEmbeddings</span><span class="p">(</span><span class="n">openai_api_key</span><span class="o">=</span><span class="n">openai_api_key</span><span class="p">)</span>
<span class="n">embeddings_search</span> <span class="o">=</span> <span class="n">Chroma</span><span class="o">.</span><span class="n">from_documents</span><span class="p">(</span><span class="n">split_content</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">)</span>
<span class="n">embeddings_search</span>
</code></pre></div>
<p>Der nächste Schritt lädt das Vorlesungsskript und die Embeddings. Diese werden dann auf das Dokument angewendet um eine Suche mit ChatGPT möglich zu machen.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># create prompt template to get usable results</span>
<span class="n">prompt_template_text_document</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Instruction:</span>
<span class="s2">- Use the following pieces of context to answer the question at the end.</span>
<span class="s2">- If you don&#39;t know the answer output: NULL</span>
<span class="s2">- Just answer the question without providing any additional information</span>

<span class="s2">Context:</span>
<span class="s2">    </span><span class="si">{context}</span>

<span class="s2">Question:</span>
<span class="s2">    </span><span class="si">{question}</span>

<span class="s2">Answer:</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">prompt_template_documents</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="n">prompt_template_text_document</span><span class="p">,</span> <span class="n">input_variables</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;context&#39;</span><span class="p">,</span> <span class="s1">&#39;question&#39;</span><span class="p">])</span>
<span class="n">chain_type_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;prompt&#39;</span><span class="p">:</span> <span class="n">prompt_template_documents</span><span class="p">}</span>

<span class="n">qa</span> <span class="o">=</span> <span class="n">RetrievalQA</span><span class="o">.</span><span class="n">from_chain_type</span><span class="p">(</span><span class="n">llm</span><span class="o">=</span><span class="n">llm</span><span class="p">,</span> <span class="n">chain_type</span><span class="o">=</span><span class="s1">&#39;stuff&#39;</span><span class="p">,</span> <span class="n">retriever</span><span class="o">=</span><span class="n">embeddings_search</span><span class="o">.</span><span class="n">as_retriever</span><span class="p">(),</span> <span class="n">chain_type_kwargs</span><span class="o">=</span><span class="n">chain_type_kwargs</span><span class="p">)</span>

<span class="n">query_topics</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Which topics should be covered in the podcast about </span><span class="si">{</span><span class="n">topic</span><span class="si">}</span><span class="s1">?&#39;</span>
<span class="n">res_topics</span> <span class="o">=</span> <span class="n">qa</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">query_topics</span><span class="p">)</span>
</code></pre></div>
<p>Um eine effiziente und aussagekräftige Suche zu erstellen ist es wichtig eine gute <a href="https://python.langchain.com/en/latest/modules/prompts/prompt_templates.html"><code>Prompt Template</code></a> zu benutzen. Diese Struktur orientiert sich an <a href="https://github.com/Significant-Gravitas/Auto-GPT">AutoGPT</a>. Wir definieren unsere Bedinungen, geben den Kontext an, stellen anschließend unsere Frage und speichern die Antwort.
Nachdem wir jetzt unsere Teil-Themen herausgefunden haben, wollen wir zu ihnen und dem Haupttehema eine Internetrecherche durchführen.</p>
<div class="highlight"><pre><span></span><code><span class="n">tools</span> <span class="o">=</span> <span class="n">load_tools</span><span class="p">([</span><span class="s1">&#39;serpapi&#39;</span><span class="p">],</span> <span class="n">llm</span><span class="o">=</span><span class="n">llm</span><span class="p">)</span>
<span class="n">agent</span> <span class="o">=</span> <span class="n">initialize_agent</span><span class="p">(</span><span class="n">tools</span><span class="p">,</span> <span class="n">llm</span><span class="p">,</span> <span class="n">agent</span><span class="o">=</span><span class="n">AgentType</span><span class="o">.</span><span class="n">ZERO_SHOT_REACT_DESCRIPTION</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># do a web research for all topics</span>
<span class="n">all_topics</span> <span class="o">=</span> <span class="p">[</span><span class="n">topic</span><span class="p">,</span> <span class="o">*</span><span class="n">formatted_topics</span><span class="p">]</span>
<span class="n">web_research</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">topic</span> <span class="ow">in</span> <span class="n">all_topics</span><span class="p">:</span>
    <span class="n">agent_res</span> <span class="o">=</span> <span class="n">agent</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Task: Do a thorough web research about </span><span class="si">{</span><span class="n">topic</span><span class="si">}</span><span class="s2">. Provide at least 3 sentences of information.&quot;</span><span class="p">)</span>
    <span class="n">web_research</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agent_res</span><span class="p">)</span>
</code></pre></div>
<p>Für dieses Szenario bietet uns LangChain sehr mächtige Konzepte an. Und zwar <a href="https://python.langchain.com/en/latest/modules/agents/tools.html">Tools</a> und <a href="https://python.langchain.com/en/latest/modules/agents.html">Agents</a>. Mit deren Hilfe kann ChatGPT selbst definieren welche Informationen es für die Recherche benötigt und gegebenenfalls wiederholte Suchanfragen für verwandte und Unterthemen stellen um das best mögliche Ergebnis zu erzielen.</p>
<blockquote>
<p>Für die Nutzung des 'serpapi' tools wird ein weiterer API Key benötigt. Siehe <a href="https://serpapi.com/">SerpApi</a></p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">prompt_template_text_script</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Sub Topics:</span>
<span class="s2">  </span><span class="si">{sub_topics}</span>

<span class="s2">Context:</span>
<span class="s2">  </span><span class="se">\&quot;</span><span class="si">{context}</span><span class="se">\&quot;</span>

<span class="s2">Podcast Participants:</span>
<span class="s2">  - Host</span>
<span class="s2">  - Expert</span>

<span class="s2">Previous Section of the Podcast Script:</span>
<span class="s2">  </span><span class="se">\&quot;</span><span class="si">{previous_section}</span><span class="se">\&quot;</span>

<span class="s2">Task:</span>
<span class="s2">  - Your task is to write a podcast script about </span><span class="se">\&quot;</span><span class="si">{topic}</span><span class="se">\&quot;</span><span class="s2">.</span>
<span class="s2">  - The Sub Topics refine the main topic and need to be addressed!</span>
<span class="s2">  - Use your own knowledge and the one provided in Context if you think it fit the topic.</span>
<span class="s2">  - Continue from the previous section and output the new content.</span>
<span class="s2">  - If you think you are done output [END]</span>

<span class="s2">&quot;&quot;&quot;</span>
<span class="n">prompt_template_podcast</span> <span class="o">=</span> <span class="n">PromptTemplate</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="n">prompt_template_text_script</span><span class="p">,</span> <span class="n">input_variables</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sub_topics&#39;</span><span class="p">,</span> <span class="s1">&#39;context&#39;</span><span class="p">,</span> <span class="s1">&#39;topic&#39;</span><span class="p">,</span> <span class="s1">&#39;previous_section&#39;</span><span class="p">])</span>

<span class="c1"># generate the podcast script like before just now with the serpapi agent web research</span>
<span class="n">podcast_chain</span> <span class="o">=</span> <span class="n">LLMChain</span><span class="p">(</span><span class="n">llm</span><span class="o">=</span><span class="n">llm</span><span class="p">,</span> <span class="n">prompt</span><span class="o">=</span><span class="n">prompt_template_podcast</span><span class="p">)</span>

<span class="n">podcast_script_web</span> <span class="o">=</span> <span class="n">run_repeated_chain</span><span class="p">(</span><span class="n">podcast_chain</span><span class="p">,</span> <span class="n">sub_topics</span><span class="o">=</span><span class="n">sub_topics</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">formatted_web_research</span><span class="p">,</span> <span class="n">topic</span><span class="o">=</span><span class="n">topic</span><span class="p">,</span> <span class="n">previous_section</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">podcast_script_web</span>
</code></pre></div>
<p>Mit den gesammelten Informationen ist es uns jetzt möglich den Podcast zu erstellen. Dafür definieren wir uns num wieder einen passenden Prompt. Das besondere an diesem ist allerdings, dass er auf der Grundlage des vorherigen Abschnitts des Podcast Skripts den nächsten erstellt. Jetzt ist die logische Frage: Warum ist das notwendig? Können wir uns nicht einfach das ganze Skript auf einmal erstellen lassen?
Die traurige Antwort auf diese Frage ist leider nein. Das liegt daran, dass <em>GPT3.5</em> ein maximales Eingabe- &amp; Ausgabelimit hat. Dieses liegt bei 4096. Wenn wir also einen längern Podcast erstellen wollen müssen wir in einem iterativen Prozess vorgehen. Das macht die selbst definierte Funktion <code>run_repeated_chain</code>. Sie wird so oft ausgeführt bis das Stop Wort <code>[END]</code> erreicht wird, oder ein Limit für die maximalen Iterationen (Standardwert: <code>8</code>).
Am Ende bekommen wir ein hochwertiges Podcastskript, dessen Erstellung mit LangChain auf triviale Weise möglich war. Selbst an diesem einfachen Beispiel können wir die Macht eines Toolsets sehen, dass LLMs mit anderen Diensten und Pipelines integriert.</p>
<h3 id="34-eine-neue-art-des-programmierens-prompt-engineering">3.4 Eine Neue Art des Programmierens: Prompt Engineering</h3>
<p>Wie wir an dem Code der Demo sehen konnten ist ein integraler Teil immer wieder aufgetaucht: Die spezifische Syntax der <code>PromptTemplates</code>. Warum ist dies nun so wichtig? Na weil LLMs einen riesigen Wissensschatz in sich bergen, aber man kann diesen nicht auf optimale Art und Weise nutzen, wenn man nicht dazu in der Lage ist auf die richtige Art und Weise Fragen und Anweisungen zu stellen. Um dieses Problem zu lösen is das neue Gebiet des <a href="https://de.wikipedia.org/wiki/Prompt_Engineering">Prompt Engineerings</a> entstanden.</p>
<p>Im Kontext von LangChain wird diese Technik nochmal wichtiger. Wie wir schon gesehen haben können wir uns damit Daten von privaten Dateien und aktuelle Berichte aus dem Internet abholen. Diese müssen nun aber in einer definierten und optimierten Weise von ChatGPT ausgewertet werden. Auf Grundlage dessen wird nun eine Aufgabe definiert und eine Richtung vorgegeben. Dies wäre unmöglich ohne die richtigen Prompts zu lösen und würde verschiedenes, sowie unauswertbares Verhalten hervorrufen. Eine Definition eines Ablaufs wäre somit nicht tragbar.</p>
<p>Wenn wir auf unser Beispiel mit dem Podcast Skript zurückgehen sehen wir, dass die Prompts ChatGPT dazu auffordern mehrere Bedingungen zu erfüllen und definieren, wie sie zu erfüllen sind. Wir sehen hier immer wieder die klare Struktur, welche mehrere Anforderungen stellt, denn Kontext angibt und eine Hauptaufgabe enthält.</p>
<p>Natürlich kann sich je nach Themengebiet und Aufgabenanforderung die Form des Prompt verändern. Das Gebiet des <em>Prompt Engineering</em> ist noch sehr jung und vieles ist unbekannt. Man kann immer bessere Eingaben mit viel Testen und innovativen Ideen erreichen. Zum Beispiel wird vermutet, dass das Aussehen der Prompts mit der Struktur der Trainingsdaten korreliert. Außerdem sehen wir, dass die je nach verwendetem LLM die Syntax der Prompts verändert werden muss um bessere Ergebnisse zu erzielen. Allerdings ist im Moment noch nichts mit Sicherheit zu sagen und dies bleibt ein Gebiet aktiver Forschung.</p>
<p>Eines können wir jedoch feststellen, und zwar das dieses Gebiet nicht mehr ein belächelt werden sollte. Um das volle Potential von LLMs auszuschöpfen müssen wir wie mit Google Suchanfragen lernen, wie wir sie am besten stellen können.</p>
<p>Trotzdem möchte hier nochmal gesagt sein, dass die Technik des <em>Prompt Engineering</em> nicht die allgemeinen Limitationen von LLMs überkommen kann.</p>
<h3 id="35-open-source-alternativen">3.5 Open Source Alternativen</h3>
<p>Wenn man sich die jetzige Lage von LLM Anbietern anschaut zeichnet sich ein klarer Trend ab. Proprietäre, gigantische Tech-Konzerne wie OpenAI, Microsoft, Google, etc. dominieren den Markt. Vor allem ChatGPT mit den zugrunde liegenden Modellen <em>GPT3.5-turbo</em> und <em>GPT4</em> sind ihrer Konkurrenz meilenweit voraus.</p>
<p>Allerdings sollte man niemals die Macht der <em>Open Source Community</em> unterschätzen. Nach dem Leak des Models <em>LLaMA</em> von Meta ist eine neue Welle von Open Source LLMs entstanden. Diese sind zwar nicht so leistungsstark wie ihre proprietären Pendants, aber sie stellen den Anfang einer Gegenbewegung dar.</p>
<p>Vor allem sticht das <em>Vicuna-13B</em> Model heraus, welches, obwohl es "nur" 13 Milliarden Parameter hat auf 92% der Leistung von <em>GPT3.5-turbo</em> kommt. Dies ist nochmal beindruckender, wenn man bedenkt dass das OpenAI Model 175 Milliarden Parameter besitzt.</p>
<figure>
<p><img alt="ChatGPT, Bard, Vicuna13B performance" src="https://lmsys.org/images/blog/vicuna/chart.svg" />
  </p>
<figcaption>ChatGPT, Bard, Vicuna13B im Vergleich</figcaption>
</figure>
<p>Allerdings haben die <em>Open Source</em> Varianten große Probleme zu lösen:</p>
<ol>
<li>
<p>Trainings Ressourcen
   Wie zu erwarten stellt die Notwendigkeit von exorbitanter Rechenleistung zum Training dieser Modelle ein unglaublich großes Problem für den normalen Programmieren / KI Experten da. Einzelne Personen haben einfach nicht die Möglichkeiten Modelle mit Milliarden über Milliarden Parameter zu trainieren und sind abhängig von guten Willen von Organisationen, was das angeht. Um diese Probleme zu adressieren ist ein sehr interessantes Projekt zum dezentralisierten Training, also jeder Nutzer im Netzwerk trägt einen kleinen Teil dazu bei, aufgetaucht. Wenn Sie mehr wissen wollen geht es hier zum <a href="https://github.com/bigscience-workshop/petals">Petals Projekt</a>.</p>
</li>
<li>
<p>Datensätze
   Bei den Datensätzen haben wir ein ähnliches Problem wie bei den Rechenressourcen. Selbst um die "kleineren" Open Source Modell zu trainieren sind schon Unmengen an Daten notwendig. Natürlich sind auch große öffentlich zugängliche Datensätze vorhanden, diese sind allerdings nicht in Größe und Qualität mit denen der großen Tech-Konzerne zu vergleichen. Findig wie eh und je hat die Community einen cleveren "Workaround" gefunden. Und zwar benutzen die Entwickler ChatGPT zur Erstellung von Trainingsdaten. Diese hat aber das Problem, dass das zu trainierend Modell somit nicht besser als sein Trainer werden kann.</p>
</li>
<li>
<p>Imitieren vs. Verstehen
   Beim Trainieren von Open Source Modellen mit ChatGPT ist den Entwicklern eine Sache immer wieder aufgefallen. Und zwar dass wir exzellente Antworten auf dagewesene Probleme bekommen, aber sobald Probleme, die eine Art von Transferleistung erfordern gelöst werden sollen, die Open Source Modelle kläglich scheitern. Das wurde dann als Schwäche im Trainingsprozess festgemacht und neuere Ansätze fahren nun eine verbesserte Strategie. Sie lassen sich von ChatGPT den logischen Denkverlauf darlegen und lernen diesen in einem mehrschrittigen Prozess. Es hat sich gezeigt, dass selbst bei kleineren Modellen ein signifikanter Leistungsschub erreicht werden kann.</p>
</li>
</ol>
<p>Zusammenfassend ist es wichtig eine wachsende Open Source Community, sowie performante offene Modelle zu haben. Dies fördert Wettbewerb, Privatsphäre und das Aufkommen von kreativen Ideen. Diversität fördert Fortschritt und Fortschritt ist der Inbegriff dieses faszinierenden Gebietes.</p>
<h2 id="4-fazit">4 Fazit</h2>
<p><strong>Leistungsstarke Sprachverarbeitung</strong>: LLMs wie GPT-4 oder Bard sind äußerst leistungsfähige Modelle, die eine breite Palette von sprachlichen Aufgaben bewältigen können. Sie können Texte generieren, Fragen beantworten, Übersetzungen liefern, Dialoge führen und vieles mehr. Ihre Fähigkeiten haben sich in den letzten Jahren erheblich verbessert und sie können mittlerweile oft erstaunlich menschenähnliche Antworten liefern. Das hat sie zu einem der vielversprechendsten Bereiche der KI-Forschung gemacht und deren Einsatzmöglichkeiten sind noch lange nicht ausgeschöpft.</p>
<p><strong>Kreative Textgenerierung</strong>: LLMs haben gezeigt, dass sie in der Lage sind, kreativen Text zu generieren, wie Gedichte, Geschichten oder Songtexte. Sie können auf der Grundlage des ihnen gegebenen Kontextes innovative und unterhaltsame Inhalte erstellen. Dies hat das Interesse von Künstlern, Schriftstellern und Kreativen geweckt, die LLMs als Werkzeug zur Inspiration und Unterstützung nutzen können. Auch Google ist auf diesen Zug aufgesprungen und verfolgt das Ziel, dass Menschen sich zukünftig nur noch für die wichtigsten Aufgaben konzentrieren müssen, während die Maschinen den Rest erledigen.</p>
<p><strong>Herausforderungen der Ethik und Verantwortung</strong>: Mit der Macht der LLMs kommen auch ethische und verantwortungsvolle Bedenken. LLMs lernen aus großen Mengen an Textdaten und spiegeln daher die Vorurteile und Verzerrungen wider, die in diesen Daten enthalten sind. Dies kann zu ungewollter Diskriminierung, Fehlinformationen oder der Verbreitung von Hassrede führen. Die Forschung und Entwicklung von LLMs erfordert daher eine bewusste Auseinandersetzung mit diesen Fragen und die Implementierung von Mechanismen zur Vermeidung von Missbrauch.</p>
<p><strong>Datenschutz und Sicherheit</strong>: Der Betrieb von LLMs erfordert große Mengen an Daten, um gute Leistungen zu erzielen. Dies stellt eine Herausforderung für den Datenschutz dar, insbesondere wenn sensible Informationen in die Modelle eingegeben werden. Der Schutz der Privatsphäre und die Gewährleistung der Datensicherheit müssen bei der Verwendung von LLMs berücksichtigt werden, um Missbrauch oder Datenlecks zu vermeiden.</p>
<p><strong>Chancen und Potenziale</strong>: Trotz der Herausforderungen bieten LLMs auch viele Chancen und Potenziale. Sie können beispielsweise in Bildungssystemen eingesetzt werden, um personalisierte Lerninhalte bereitzustellen oder bei der Automatisierung von Kundeninteraktionen in Unternehmen helfen. LLMs könnten auch bei der Bewältigung komplexer Probleme wie der medizinischen Diagnose oder der Entwicklung neuer Materialien unterstützen. Darüber hinaus können LLMs durch ihre beeindruckende Fähigkeit zur Textgenerierung auch kreative Prozesse in der Softwareentwicklung unterstützen. Sie können Code generieren, der von professionellen Entwicklern weiterverarbeitet werden kann, wodurch diese sich auf den Kern der Aufgabe konzentrieren können. Dies stellt nur ein konkretes Beispiel von vielen dar, wie LLMs die Arbeit von Menschen unterstützen können, ohne sie zu ersetzen.</p>
<div class="admonition summary">
<p class="admonition-title">Fazit</p>
<p>LLMs sind eine der spannendsten und vielversprechendsten Technologien der letzten Jahre. Sie haben das Potential die Art und Weise wie wir mit Computern interagieren zu revolutionieren. Allerdings sind sie noch nicht perfekt und haben ihre Limitationen. Diese sind aber nicht unüberwindbar und mit der Zeit werden sie immer besser werden. Es ist wichtig sich mit dieser Technologie auseinanderzusetzen und sie zu verstehen, denn sie wird in Zukunft immer bedeutender werden.</p>
</div>
<h2 id="5-weiterfuhrendes-material">5 Weiterführendes Material</h2>
<h3 id="51-podcast">5.1 Podcast</h3>
<p>Hier einfach den Podcast embedden.
<a href="https://der-campustalk-der-thd.letscast.fm/episode/der-campus-talk-silicon-forest-folge-3">Der Campus Talk – Silicon Forest – Folge 3</a></p>
<h3 id="52-talk">5.2 Talk</h3>
<p>Hier einfach Youtube oder THD System embedden.</p>
<h3 id="53-demo">5.3 Demo</h3>
<p>Link zum Repository: <a href="https://github.com/CRY-TeX/demo-ki-seminar">demo-ki-seminar</a></p>
<h2 id="6-literaturliste">6 Literaturliste</h2>
<p>Acheampong, Francisca Adoma, Henry Nunoo-Mensah, und Wenyu Chen. „Transformer Models for Text-Based Emotion Detection: A Review of BERT-Based Approaches“. Artificial Intelligence Review 54, Nr. 8 (1. Dezember 2021): 5789–5829. https://doi.org/10.1007/s10462-021-09958-2.</p>
<p>Alammar, Jay. „The Illustrated Transformer“. Zugegriffen 18. Juni 2023. http://jalammar.github.io/illustrated-transformer/.</p>
<p>Amirhossein Kazemnejad. „Transformer Architecture: The Positional Encoding - Amirhossein Kazemnejad’s Blog“. Zugegriffen 18. Juni 2023. https://kazemnejad.com/blog/transformer_architecture_positional_encoding/.</p>
<p>Bojanowski, Piotr, Edouard Grave, Armand Joulin, und Tomas Mikolov. „Enriching Word Vectors with Subword Information“. arXiv, 19. Juni 2017. http://arxiv.org/abs/1607.04606.</p>
<p>Brants, Thorsten, Ashok C Popat, Peng Xu, Franz J Och, und Jeffrey Dean. „Large Language Models in Machine Translation“, o. J.</p>
<p>Brown, Tom B., Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, u. a. „Language Models are Few-Shot Learners“. arXiv, 22. Juli 2020. http://arxiv.org/abs/2005.14165.</p>
<p>Carlini, Nicholas, Florian Tramèr, Eric Wallace, Matthew Jagielski, Ariel Herbert-Voss, Katherine Lee, Adam Roberts, u. a. „Extracting Training Data from Large Language Models“, o. J. https://www.usenix.org/system/files/sec21-carlini-extracting.pdf.</p>
<p>DeepMind x UCL | Deep Learning Lectures | 6/12 | Sequences and Recurrent Networks, 2020. https://www.youtube.com/watch?v=87kLfzmYBy8.</p>
<p>DeepMind x UCL | Deep Learning Lectures | 7/12 | Deep Learning for Natural Language Processing, 2020. https://www.youtube.com/watch?v=8zAP2qWAsKg.</p>
<p>Devlin, Jacob, Ming-Wei Chang, Kenton Lee, und Kristina Toutanova. „BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding“. arXiv, 24. Mai 2019. http://arxiv.org/abs/1810.04805.</p>
<p>Domingos, Pedro. „A Few Useful Things to Know about Machine Learning“. Communications of the ACM 55, Nr. 10 (Oktober 2012): 78–87. https://doi.org/10.1145/2347736.2347755.</p>
<p>Floridi, Luciano. „AI as Agency Without Intelligence: On ChatGPT, Large Language Models, and Other Generative Models“. Philosophy &amp; Technology 36, Nr. 1 (10. März 2023): 15. https://doi.org/10.1007/s13347-023-00621-y.</p>
<p>google. „Classify Text with BERT | Text“. TensorFlow. Zugegriffen 1. April 2023. https://www.tensorflow.org/text/tutorials/classify_text_with_bert.</p>
<p>Hassan, Abdalraouf, und Ausif Mahmood. „Efficient Deep Learning Model for Text Classification Based on Recurrent and Convolutional Layers“. In 2017 16th IEEE International Conference on Machine Learning and Applications (ICMLA), 1108–13, 2017. https://doi.org/10.1109/ICMLA.2017.00009.</p>
<p>Holtzman, Ari, Jan Buys, Li Du, Maxwell Forbes, und Yejin Choi. „The Curious Case of Neural Text Degeneration“. arXiv, 14. Februar 2020. http://arxiv.org/abs/1904.09751.</p>
<p>Kaplan, Jared, Sam McCandlish, Tom Henighan, Tom B. Brown, Benjamin Chess, Rewon Child, Scott Gray, Alec Radford, Jeffrey Wu, und Dario Amodei. „Scaling Laws for Neural Language Models“. arXiv, 22. Januar 2020. http://arxiv.org/abs/2001.08361.</p>
<p>Kim, Sang-Bum, Kyoung-Soo Han, Hae-Chang Rim, und Sung-Hyon Myaeng. „Some Effective Techniques for Naive Bayes Text Classification“. Knowledge and Data Engineering, IEEE Transactions on 18 (1. Dezember 2006): 1457–66. https://doi.org/10.1109/TKDE.2006.180.</p>
<p>lbayad, Maha, Laurent Besacier, und Jakob Verbeek. „Pervasive Attention: 2D Convolutional Neural Networks for Sequence-to-Sequence Prediction“. arXiv, 1. November 2018. https://doi.org/10.48550/arXiv.1808.03867.</p>
<p>Luitse, Dieuwertje, und Wiebke Denkena. „The great Transformer: Examining the role of large language models in the political economy of AI“. Big Data &amp; Society 8, Nr. 2 (1. Juli 2021): 20539517211047736. https://doi.org/10.1177/20539517211047734.</p>
<p>Liu, Pengfei, Xipeng Qiu, und Xuanjing Huang. „Recurrent Neural Network for Text Classification with Multi-Task Learning“. arXiv, 17. Mai 2016. https://doi.org/10.48550/arXiv.1605.05101.</p>
<p>Liu, Shengzhong, Franck Le, Supriyo Chakraborty, und Tarek Abdelzaher. „On Exploring Attention-based Explanation for Transformer Models in Text Classification“. In 2021 IEEE International Conference on Big Data (Big Data), 1193–1203, 2021. https://doi.org/10.1109/BigData52589.2021.9671639.</p>
<p>Manyika, James. „An Overview of Bard: An Early Experiment with Generative AI“, o. J. https://ai.google/static/documents/google-about-bard.pdf.</p>
<p>McCallum, Andrew, und Kamal Nigam. „A Comparison of Event Models for Naive Bayes Text Classification“, o. J. http://www.cs.cmu.edu/~dgovinda/pdf/multinomial-aaaiws98.pdf.</p>
<p>McCoy, R. Thomas, Ellie Pavlick, und Tal Linzen. „Right for the Wrong Reasons: Diagnosing Syntactic Heuristics in Natural Language Inference“. arXiv, 24. Juni 2019. http://arxiv.org/abs/1902.01007.</p>
<p>Merity, Stephen, Nitish Shirish Keskar, und Richard Socher. „Regularizing and Optimizing LSTM Language Models“. arXiv, 7. August 2017. https://doi.org/10.48550/arXiv.1708.02182.</p>
<p>Mikolov, Tomáš, Anoop Deoras, Daniel Povey, Lukáš Burget, und Jan Černocký. „Strategies for training large scale neural network language models“. In 2011 IEEE Workshop on Automatic Speech Recognition &amp; Understanding, 196–201, 2011. https://doi.org/10.1109/ASRU.2011.6163930.</p>
<p>Min, Bonan, Hayley Ross, Elior Sulem, Amir Pouran Ben Veyseh, Thien Huu Nguyen, Oscar Sainz, Eneko Agirre, Ilana Heinz, und Dan Roth. „Recent Advances in Natural Language Processing via Large Pre-Trained Language Models: A Survey“. arXiv, 1. November 2021. http://arxiv.org/abs/2111.01243.</p>
<p>OpenAI. „GPT-4 Technical Report“. arXiv, 27. März 2023. https://doi.org/10.48550/arXiv.2303.08774.</p>
<p>Ouyang, Long, Jeff Wu, Xu Jiang, Diogo Almeida, Carroll L. Wainwright, Pamela Mishkin, Chong Zhang, u. a. „Training language models to follow instructions with human feedback“. arXiv, 4. März 2022. http://arxiv.org/abs/2203.02155.</p>
<p>Peters, Matthew E., Mark Neumann, Mohit Iyyer, Matt Gardner, Christopher Clark, Kenton Lee, und Luke Zettlemoyer. „Deep contextualized word representations“. arXiv, 22. März 2018. http://arxiv.org/abs/1802.05365.</p>
<p>Radford, Alec, Karthik Narasimhan, Tim Salimans, und Ilya Sutskever. „Improving Language Understanding by Generative Pre-Training“, o. J. https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf.</p>
<p>Rei, Marek. „Semi-supervised Multitask Learning for Sequence Labeling“. arXiv, 24. April 2017. http://arxiv.org/abs/1704.07156.</p>
<p>Shin, Andrew, Masato Ishii, und Takuya Narihira. „Perspectives and Prospects on Transformer Architecture for Cross-Modal Tasks with Language and Vision“. International Journal of Computer Vision 130, Nr. 2 (1. Februar 2022): 435–54. https://doi.org/10.1007/s11263-021-01547-8.</p>
<p>Sidorov, Grigori, Francisco Castillo, Efstathios Stamatatos, Alexander Gelbukh, und Liliana Chanona-Hernández. „Syntactic N-grams as machine learning features for natural language processing“. Expert Systems with Applications: An International Journal 41 (1. Februar 2014): 853–60. https://doi.org/10.1016/j.eswa.2013.08.015.</p>
<p>Sundermeyer, Martin, Ralf Schlüter, und Hermann Ney. „LSTM Neural Networks for Language Modeling“. In Interspeech 2012, 194–97. ISCA, 2012. https://doi.org/10.21437/Interspeech.2012-65.</p>
<p>TensorFlow. „Neural Machine Translation with a Transformer and Keras | Text“. TensorFlow. Zugegriffen 1. April 2023. https://www.tensorflow.org/text/tutorials/transformer.</p>
<p>TensorFlow. „Text Classification with an RNN | TensorFlow“. Zugegriffen 1. April 2023. https://www.tensorflow.org/text/tutorials/text_classification_rnn.</p>
<p>Thoppilan, Romal, Daniel De Freitas, Jamie Hall, Noam Shazeer, Apoorv Kulshreshtha, Heng-Tze Cheng, Alicia Jin, u. a. „LaMDA: Language Models for Dialog Applications“. arXiv, 10. Februar 2022. http://arxiv.org/abs/2201.08239.</p>
<p>Topal, M Onat, Anil Bas, und Imke van Heerden. „Exploring Transformers in Natural Language Generation: GPT, BERT, and XLNet“, o. J. https://arxiv.org/abs/2102.08036.</p>
<p>Tunstall, Lewis, Leandro von Werra, und Thomas Wolf. Natural Language Processing with Transformers. O’Reilly Media, Inc., 2022.</p>
<p>Vaswani, Ashish, Noam Shazeer, Niki Parmar, akob Uszkoreit, Llion Jones, Aidan N. Gomez, Łukasz Kaiser, und Illia Polosukhin. „Transformer: A Novel Neural Network Architecture for Language Understanding“, 31. August 2017. https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html.</p>
<p>Vaswani, Ashish, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Łukasz Kaiser, und Illia Polosukhin. „Attention is All you Need“. In Advances in Neural Information Processing Systems, Bd. 30. Curran Associates, Inc., 2017. https://proceedings.neurips.cc/paper_files/paper/2017/hash/3f5ee243547dee91fbd053c1c4a845aa-Abstract.html.</p>
<p>Yan, Xueming, Zhihang Fang, und Yaochu Jin. „Augmented Transformers with Adaptive n-grams Embedding for Multilingual Scene Text Recognition“. arXiv, 27. Februar 2023. http://arxiv.org/abs/2302.14261.</p>
<p>Zhou, Chunting, Chonglin Sun, Zhiyuan Liu, und Francis C. M. Lau. „A C-LSTM Neural Network for Text Classification“. arXiv, 30. November 2015. http://arxiv.org/abs/1511.08630.</p>
<p>Zhu, Q., und J. Luo. „Generative Pre-Trained Transformer for Design Concept Generation: An Exploration“. Proceedings of the Design Society 2 (Mai 2022): 1825–34. https://doi.org/10.1017/pds.2022.185.</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.expand", "navigation.indexes"], "search": "../../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.220ee61c.min.js"></script>
      
        
          <script src="../../javascripts/katex.js"></script>
        
      
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
        
      
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
        
      
    
  </body>
</html>