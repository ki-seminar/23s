
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../LLMs/">
      
      
        <link rel="next" href="../T09_Dialekte_Spracherkennung/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.1, mkdocs-material-9.1.21">
    
    
      
        <title>Spracherkennung - Seminar Aktuelle Themen der künstlichen Intelligenz</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.eebd395e.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
      <link rel="stylesheet" href="../../javascripts/mathjax.js">
    
      <link rel="stylesheet" href="https://polyfill.io/v3/polyfill.min.js?features=es6">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#spracherkennung" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Seminar Aktuelle Themen der künstlichen Intelligenz" class="md-header__button md-logo" aria-label="Seminar Aktuelle Themen der künstlichen Intelligenz" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Seminar Aktuelle Themen der künstlichen Intelligenz
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Spracherkennung
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Seminar Aktuelle Themen der künstlichen Intelligenz" class="md-nav__button md-logo" aria-label="Seminar Aktuelle Themen der künstlichen Intelligenz" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Seminar Aktuelle Themen der künstlichen Intelligenz
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Aktuelles
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
      
      
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          Themen
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          Themen
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Einf%C3%A4rben%20von%20Bildern/" class="md-nav__link">
        Einfärben von Bildern - Zwei Ansätze
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Empfehlungssysteme/" class="md-nav__link">
        Empfehlungssysteme
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Face_Aging/" class="md-nav__link">
        Face Aging
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../LLMs/" class="md-nav__link">
        Large Language Models
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Spracherkennung
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Spracherkennung
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstract" class="md-nav__link">
    Abstract
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-einleitung-motivation" class="md-nav__link">
    1 Einleitung / Motivation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-geschichte-der-spracherkennung" class="md-nav__link">
    2 Geschichte der Spracherkennung
  </a>
  
    <nav class="md-nav" aria-label="2 Geschichte der Spracherkennung">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1950er-und-1960er" class="md-nav__link">
    1950er und 1960er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1970er" class="md-nav__link">
    1970er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1980er" class="md-nav__link">
    1980er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1990er" class="md-nav__link">
    1990er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2000er" class="md-nav__link">
    2000er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2010er" class="md-nav__link">
    2010er
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-deep-learning-und-spracherkennung" class="md-nav__link">
    3 Deep Learning und Spracherkennung
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-speech-transformer-architektur" class="md-nav__link">
    4 Speech Transformer Architektur
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-anwendung" class="md-nav__link">
    5 Anwendung
  </a>
  
    <nav class="md-nav" aria-label="5 Anwendung">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#code-demo" class="md-nav__link">
    Code-Demo
  </a>
  
    <nav class="md-nav" aria-label="Code-Demo">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dataset" class="md-nav__link">
    Dataset
  </a>
  
    <nav class="md-nav" aria-label="Dataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-ingestion" class="md-nav__link">
    Data Ingestion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-transformation" class="md-nav__link">
    Data Transformation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beispiel-der-umformung-eines-datensets" class="md-nav__link">
    Beispiel der Umformung eines Datensets
  </a>
  
    <nav class="md-nav" aria-label="Beispiel der Umformung eines Datensets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-integration" class="md-nav__link">
    Data Integration
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#preprocessing" class="md-nav__link">
    Preprocessing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1model-gaussian-hmm" class="md-nav__link">
    1.Model: Gaussian HMM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2model-wav2vec" class="md-nav__link">
    2.Model: Wav2vec
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-weiterfuhrendes-material" class="md-nav__link">
    6 Weiterführendes Material
  </a>
  
    <nav class="md-nav" aria-label="6 Weiterführendes Material">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#podcast" class="md-nav__link">
    Podcast
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#podcast-transkript" class="md-nav__link">
    Podcast Transkript
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#talk" class="md-nav__link">
    Talk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#demo" class="md-nav__link">
    Demo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-literaturliste" class="md-nav__link">
    7 Literaturliste
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../T09_Dialekte_Spracherkennung/" class="md-nav__link">
        T09 - Dialekte in der Spracherkennung
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../T12_feature-extraction/" class="md-nav__link">
        Feature Extraction
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../TextToSpeech/" class="md-nav__link">
        Text-to-Speech
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../Zeitserienanalyse/" class="md-nav__link">
        Zeitserienanalyse
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bayesian_modeling/" class="md-nav__link">
        Bayesian Modeling
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../t7_Process_Mining/" class="md-nav__link">
        Process Mining
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../transfer_learning_nlp/" class="md-nav__link">
        Transfer Learning in der Sprachverarbeitung
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../impressum/" class="md-nav__link">
        Impressum
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#abstract" class="md-nav__link">
    Abstract
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#1-einleitung-motivation" class="md-nav__link">
    1 Einleitung / Motivation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-geschichte-der-spracherkennung" class="md-nav__link">
    2 Geschichte der Spracherkennung
  </a>
  
    <nav class="md-nav" aria-label="2 Geschichte der Spracherkennung">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1950er-und-1960er" class="md-nav__link">
    1950er und 1960er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1970er" class="md-nav__link">
    1970er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1980er" class="md-nav__link">
    1980er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1990er" class="md-nav__link">
    1990er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2000er" class="md-nav__link">
    2000er
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2010er" class="md-nav__link">
    2010er
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-deep-learning-und-spracherkennung" class="md-nav__link">
    3 Deep Learning und Spracherkennung
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-speech-transformer-architektur" class="md-nav__link">
    4 Speech Transformer Architektur
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-anwendung" class="md-nav__link">
    5 Anwendung
  </a>
  
    <nav class="md-nav" aria-label="5 Anwendung">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#code-demo" class="md-nav__link">
    Code-Demo
  </a>
  
    <nav class="md-nav" aria-label="Code-Demo">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dataset" class="md-nav__link">
    Dataset
  </a>
  
    <nav class="md-nav" aria-label="Dataset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-ingestion" class="md-nav__link">
    Data Ingestion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-transformation" class="md-nav__link">
    Data Transformation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#beispiel-der-umformung-eines-datensets" class="md-nav__link">
    Beispiel der Umformung eines Datensets
  </a>
  
    <nav class="md-nav" aria-label="Beispiel der Umformung eines Datensets">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-integration" class="md-nav__link">
    Data Integration
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#preprocessing" class="md-nav__link">
    Preprocessing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1model-gaussian-hmm" class="md-nav__link">
    1.Model: Gaussian HMM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2model-wav2vec" class="md-nav__link">
    2.Model: Wav2vec
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#6-weiterfuhrendes-material" class="md-nav__link">
    6 Weiterführendes Material
  </a>
  
    <nav class="md-nav" aria-label="6 Weiterführendes Material">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#podcast" class="md-nav__link">
    Podcast
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#podcast-transkript" class="md-nav__link">
    Podcast Transkript
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#talk" class="md-nav__link">
    Talk
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#demo" class="md-nav__link">
    Demo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#7-literaturliste" class="md-nav__link">
    7 Literaturliste
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="spracherkennung">Spracherkennung</h1>
<p>von <em>Amir Amuri, Stefan Hagemann und Florian Hagemann</em></p>
<h2 id="abstract">Abstract</h2>
<p>Sprachverarbeitung ist heutzutage allgegenwärtig und die meisten Menschen sind bewusst oder unbewusst schon damit in Berührung gekommen. Sei es als Teil eines Sprachassistenten in einem Smartphone, in einem Auto oder in einem Smart Home, oder in einer Diktier App. Aufgrund der Präsenz des Themas in der Gesellschaft wurde in dieser Arbeit ein Podcast aufgenommen, ein Fachvortrag und eine Code-Demonstration zum Thema Spracherkennung im Rahmen der Vorlesung Seminar aktuelle Themen der KI bei Prof. Dr. Wahl ausgearbeitet und gehalten. Der Folgende Text ist eine schriftliche Ausarbeitung davon.</p>
<p>Der Podcast behandelt das Thema Spracherkennung und präsentiert Erkenntnisse eines Experten. Es werden Fragen zur Funktionsweise der Umwandlung von gesprochener Sprache in Computersprache, der Zuhörfähigkeit von Sprachassistenten, der Verantwortlichkeit bei fehlerhaften Bestellungen, dem Lernpotenzial von Künstlicher Intelligenz, der Entwicklung der Spracherkennung und zukünftigen Veränderungen diskutiert. Die Möglichkeit der Emotionserkennung in der Sprache und potenzielle Anwendungen werden ebenfalls beleuchtet. Datenschutz und ethische Aspekte werden betont. Der Podcast endet mit einem Ausblick auf kommende Entwicklungen und Vorfreude auf weitere spannende Themen.</p>
<p>Der Fachvortrag beschäftigt sich hauptsächlich mit der Entwicklung von Spracherkennung über die Zeit und welche Rolle Deep Learning dabei gespielt hat. Dabei werden verschiedene Ansätze grob erklärt oder deren idee beschrieben. Zudem wird eine State of the Art Architektur, der Speech Transformer, genauer vorgestellt und erklärt.</p>
<p>In der Code-Demonstration ist viel über das Preprocessing von Daten und deren Aufbereitung zu sehen und wie zwei verschiedene Ansätze trainiert werden können. Dabei ist einer davon klassisch und der andere ein Deep Learning Ansatz.</p>
<h2 id="1-einleitung-motivation">1 Einleitung / Motivation</h2>
<p>Es gibt keine offizielle allgemein anerkannte Definition von Spracherkennung. Eine Definition, die die wesentlichen Punkte zur Beschreibung von Spracherkennung gut zusammenfässt ist von ibm:</p>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p>Speech recognition, also known as automatic speech recognition (ASR), computer speech recognition, or speech-to-text, is a capability which enables a program to process human speech into a written format.</p>
</div>
<p>Wie sich aus der Definition erkennen lässt hat Spracherkennung viele Anwendungen. Überall dort, wo ein Computer oder eine Maschiene Die Sprache eines Menschen als akustisches Signal verstehen und verarbeiten muss kommt Spracherkennung zum Einsatz. In jedem Sprachassistenten, ob dieser in einem Handy, in einem Computer, in einem Auto oder in einem Smart Home ist, findet sich Spracherkennung als teil der Software wieder. Aber auch in Apps die Diktiertes in Text umwandeln sollen kommt es zum Einsatz. Da die Anwendungsgebiete von Spracherkennung so weitläufig sind, ist die Bedeutung des Themas und das Interesse daran klar.</p>
<p>Im Laufe der Zeit wurden verschieden Methoden angewandt um Spracherkennung zu betreiben. Dabei gibt es sowhol klassische Methoden, welche mit mathematischen oder statistischen Modellen arbeiten, und moderne Ansätze mit Deep Learning Methoden, welche mit neuronalen Netzen, die verschiedenen Architekturen haben, arbeiten.</p>
<p>Im nächsten Abschnitt wird der Schwerpunkt des Fachvortrages behandelt. Ziel ist es, einen Überblick über die Entwicklung von Spracherkennung im Laufe der Zeit zu geben, indem wichtige und interessante Ansätze, Produkte oder Vorschläge aufgezählt oder erklärt werden.</p>
<h2 id="2-geschichte-der-spracherkennung">2 Geschichte der Spracherkennung</h2>
<h3 id="1950er-und-1960er">1950er und 1960er</h3>
<p>In den 1950er Jahren wurden die ersten Spracherkennungssysteme erfunden. Damals waren die Systeme allerdings wesentlich schlechter als die, welche wir heutzutage aus bekannten Sprachassisten wie Siri oder Alexa kennen. Die ersten Systeme waren darauf fokussiert Zahlen zu erkennen.</p>
<p>1952 wurde von Bell Laboratories das "Audrey" System erfunden. Das "Audrey" System konnte nur einzelne Zahlen erkennen, die von einer Stimme gesprochen worden sind. Der Grund dafür, warum nur die gesprochenen Zahlen von einer einzigen Stimme erkannt werden konnten war, dass dafür template matching verwendet wurde.</p>
<div class="admonition info">
<p class="admonition-title">Definition</p>
<p>Template matching is the process of moving the template over the entire image and calculating the similarity between the template and the covered window on the image.</p>
</div>
<p>Im Fall der Spracherkennung ist beim template matching das Bild zum Beispiel ein Spektogramm.</p>
<p>1962 wurde von IBM "Shoebox" vorgestellt. Das System konnte 16 englische Wörter verstehen und darauf antworten. Die Spracherkennung hat funktioniert, indem Merkmale aus dem Input extrahiert und mit abgespeicherten Verglichen wurden. So wurde bestimmt welches Wort gesagt wurde.</p>
<figure>
<p><img alt="Shoebox" src="../img/Spracherkennung/ibm_shoebox.jpeg" />
  </p>
<figcaption>Fig. 1 Shoebox</figcaption>
</figure>
<p>1966 wurde Linear Predictive Coding (LPC) vorgeschlagen. Linear Predictive Coding ist ein Verfahren zur Reduktion der Datenmenge. Es basiert auf der Annahme, dass Sprachsignale viele wiederholende Muster enthalten, die durch eine Vorhersagemethode erfasst werden können. Der Vorteil von diesem Ansatz ist, dass durch die Reduktion der Datenmenge eine effizientere Verarbeitung und Übertragung von Sprache möglich ist.</p>
<p>1968 wurde Dynamic Time Warping (DTW) erfunden. Mit Dynamic Time Warping kann man die Ähnlichkeit zwischen zwei zeitlichen Signalen, die sich in Geschwindigkeit und / oder Zeitachse unterscheiden messen. Dadurch können zum Beispiel auch langsamer oder schneller ausgesprochene Wörter als in der abgespeicherten Vorlage erkannt werden. </p>
<p>Außerdem wurde zu dieser Zeit die Mathematik des Hidden Markov Models formuliert, welche aber erst später in der Spracherkennung zum Einsatz kam.</p>
<h3 id="1970er">1970er</h3>
<p>In den 1970er Jahren wurden Fortschritte in der Spracherkennung vor allem aufgrund des Speech Understanding Research (SUR) Programs von der Defense Advanced Research Project Agency (DARPA) von 1971 bis 1976 gemacht. Ziel des Programs war es, Fortschritte in der automatischen Spracherkennung und Sprachverständnisforschung zu erzielen.</p>
<p>Durch das Program ist unter anderem das "Harpy" System von der Carnegie-Mellon Universität entstanden. Das System konnte über 1000 Wörter verstehen, was ungefähr dem Vokabular eines drei Jährigem gleicht. "Harpy" war der Versuch die besten Merkmale des Hearsy-I Systems, welches ein regelbasiertes System war, und des DRAGON Systems, welches eine Markov Kette verwendete zu kombinieren. Es hatte ein State Transition Network mit 15000 states. In dem State Transition Network sind alle möglichen Pfade durch die endliche Anzahl an states dargestellt, wie zum Beispiel alle möglichen Wörter oder Sätze. Zudem waren Regeln zu Wortgrenzen und Grammatik implementiert. Durch diesen Ansatz konnte "Harpy" die für das SUR vorgesehenen Ziele, nämlich über 90 % eines Satzes aus einem Lexikon mit 1000 Wörtern verstehen zu können, erfüllen.</p>
<figure>
<p><img alt="Harpy" src="../img/Spracherkennung/Harpy.jpeg" width="400" />
  </p>
<figcaption>Fig. 2 Harpy</figcaption>
</figure>
<h3 id="1980er">1980er</h3>
<p>Der bedeutenste Fortschritt in den 1980er Jahren war die Verwendung von Hidden Markov Models für Spracherkennung. Zwar waren diese schon vorher bekannt, fanden aber erst jetzt Anwendung.</p>
<p>1986 wurde das SPHINX System von der Carnegie-Melln Universität entwickelt. Es gibt noch weitere Versionen und Verbesserungen davon, aber die erste Version verwendete ein Hidden Markov Model.</p>
<p>Ein Hidden Markov Model ist ein Modell, bei dem der zugrunde liegende Prozess eine Markov-Kette ist, aber die Zustände nicht direkt beobachtbar sind. Stattdessen werden beobachtbare Ereignisse oder Symbole (z. B. Wörter, Phoneme oder akustische Merkmale) erzeugt, die mit bestimmten Wahrscheinlichkeiten zu den zugrunde liegenden versteckten Zuständen gehören. Die versteckten Zustände sind nicht direkt sichtbar und werden als "versteckt" bezeichnet.</p>
<p>Eine Markov-Kette ist ein Modell, bei dem ein System eine Reihe von diskreten Zuständen durchläuft und sich von einem Zustand zum nächsten gemäß einer bestimmten Übergangswahrscheinlichkeit bewegt. Jeder Zustand ist direkt beobachtbar, und die Wahrscheinlichkeiten für die Zustandsübergänge sind bekannt.</p>
<p>Der Unterschied zwischen einer Markov Kette und einem Hidden Markov Model ist, dass eine Markov-Kette die Wahrscheinlichkeiten der Zustandsübergänge direkt modelliert, während ein Hidden Markov Model zusätzlich die Wahrscheinlichkeiten der beobachteten Ereignisse in Bezug auf die versteckten Zustände modelliert.</p>
<h3 id="1990er">1990er</h3>
<p>In den 1990er Jahren wurde die Spracherkennung vor allem aufgrund von Verbesserungen am persönlichen Computer vorangetrieben, da dadurch die Kommerzialisierung von Spracherkennungsssoftware möglich wurde. Durch die Erfindung von schnelleren Prozessoren konnten jetzt auch privat Personen Spracherkennungsssoftware nutzen. Neben der Kommerzialisierung, beschäftigte man sich zu dieser Zeit auch mit der Robustheit von Modellen.</p>
<p>1990 wurde zum Beispiel eine Diktiersoftware namens Dragon Dictate herausgebracht.</p>
<p>1993 hat Apple "Speakable Items", eine Sprachsteuerung für Apple Geräte herausgebracht. Hier wurden nur bestimmte bekannte Befehle durch Wortlisten und Mustererkennung erkannt.</p>
<p>1999 wurde das BellSouth Voice Portal herausgebracht. Das BellSouth Voice Portal hat den Benutzern ermöglicht sprachgesteuerte Dienste und Informationen, wie zum Beispiel die Wettervorhersage, über das Telefon zu bekommen.</p>
<h3 id="2000er">2000er</h3>
<p>Von 2002 bis 2004 gab es ein weiteres Programm der Defense Advanced Research Project Agency (DARPA) namens Effective Affordable Reusable Speech-to-Text (EARS). Durch dieses Programm wurde die Sammlung des Switchboard-Telefonkorpus, welcher 260 Stunden aufgezeichneter Gespräche von über 500 Sprechern enthält, finanziert.</p>
<p>2007 wurde GOOG-411, ein telefonischer Informationsdienst herausgebracht. Die Aufnahmen von GOOG-411 haben wertvolle Daten geliefert, die Google geholfen haben ihre Spracherkennungssysteme zu verbessern.</p>
<p>2007 wurde erstmals ein Long Short Term Memory (LSTM) mit Connectionist Temporal Classification (CTC) trainiert das angefangen hat klassische Ansätze in manchen Aufgaben zu übertreffen.</p>
<figure>
<p><img alt="CTC" src="../img/Spracherkennung/CTC.png" width="400" />
  </p>
<figcaption>Fig. 3 Connectionist Temporal Classification</figcaption>
</figure>
<p>Connectionist Temporal Classification ist ein System um ein rekurrentes Neuronales Netz zu trainieren. Dabei ist der Output des Neuronalen Netzes eine Wahrscheinlichkeitsmatrix, welche für jeden Zeitpunkt t die Wahrscheinlichkeit für jedes vorher definiertes Zeichen angibt. Anschließend wird durch einen Algorithmus der Pfad berechnet, der am Ende die höchste Wahrscheinlichkeit hat. Die Ausgabesequenz, am Beispiel von Fig. 3, wäre dann "aaa-b". Alle Buchstaben die Mehrmals hintereinander vorkommen werden zusammengefasst zu einem Buchstaben. Dabei ist zu beachten, dass es ein Platzhalter Symbol gibt welches dazu dient auch den selben Buchstaben mehrmals hintereinander zu erkennen, in diesem Beispiel durch ein "-" dargestellt. Somit ist die Ausgabe dann der richtige Output "ab".</p>
<p>2008 wurde von Google die Voice Search App für Smartphones von Apple herausgebracht. Da es Spracherkennung für Smartphones gab, konnte Google Daten von mehreren Milliarden Suchen sammeln.</p>
<p>2009 wurde ein deep feedforward neural network für acoustic modeling hergenommen. Der Ansatz für Acoustic modeling besteht darin ein feedforward neural network zu verwenden, um zu bestimmen, wie gut die jeweiligen states des Hidden Markov Models zu den einzelnen Inputs passen. Das neuronale Netz nimmt mehrere Ausschnitte von Koeffizienten des akustischen Inputs, die diesen repräsentieren und erzeugt als Ausgabe Wahrscheinlichkeiten für die Zustände des Hidden Markov Models.</p>
<h3 id="2010er">2010er</h3>
<p>2014 gab es den ersten Versuch für ein end-to-end automatic speechrecognition (ASR) system mit einem RNN-CTC Modell von Google.</p>
<p>Ein end-to-end ASR System ist ein Spracherkennungssystem, das den gesamten Prozess der Spracherkennung von der Audioeingabe bis zur Textausgabe abdeckt, ohne den Einsatz traditioneller separater Komponenten wie Sprachmerkmalsextraktion, Ausrichtung oder Sprachmodellierung.</p>
<p>2015 wurde Googles Spracherkennung durch ein CTC trainiertes LSTM sehr verbessert und wurde dann auch für Google Voice für alle mit einem Smartphone verfügbar.</p>
<p>2016 wurder das erste Aufmerksamkeitsbasierte automatic speechrecognition Model vorgeschlagen. Das Modell "Listen, Attend und Spell" (LAS) hört die akustischen Signale, achtet auf verschiedene Teile des Signals und gibt das Transkript einen Buchstaben nach dem anderen aus. Es besteht aus zwei Teilen, einem Listener und einem Speller. Der Listener ist ein Encoder recurrent neural network, genauer gesagt ein pyramidal Bidirectional Long Short Term Memory (BLSTM). Der Listener extrahiert Merkmale aus den akustische Signalen. Der Output des Listners dient als Eingabe für den Speller. Der Speller ist Aufmerksamkeitsbasierter Zeichen Decoder, genauer gesagt ein Long Short Term Memory (LSTM) der eine Wahrschenilichkeitsmatrix als Output hat.</p>
<figure>
<p><img alt="LAS" src="../img/Spracherkennung/LAS.png" width="400" />
  </p>
<figcaption>Fig. 4 "Listen, Attend, Spell"</figcaption>
</figure>
<p>Aufmerksamkeits basierte Modelle können im Gegensatz zu den Ansätzen mit Connectionist Temporal Classification oder Hidden Markov Models alle Teile eines Spracherkennungssystems lernen. Dadurch spart man sich den Speicherplatz für ein großes language model, wodurch dieser Ansatz gut für Anwendungen mit limitiertem Speicherplatz geeignet ist. Ende 2016 haben diese Modelle die Ansätze mit Connectionist Temproal Classification schon übertroffen.</p>
<p>2017 errreichten Forscher von Microsoft einen historischen Meilenstein im Bezug auf menschliche Parität bei der Transkription von Telefongesprächen. Das Modell war besser als vier proffessionelle Transkriptoren (Menschen).</p>
<p>Zudem wurde 2017 im Paper "Attention is all you need" die erste Transformer Architektur vorgestellt. Diese war aber noch nicht für Spracherkennung gedacht, sondern für machine translation.</p>
<p>2018 wurde dann die Speech Transformer Architektur im Paper Speech-Transformer: A No-Recurrence Sequence-to-Sequence Model for Speech Recognition vorgestellt. Diese Archtektur ist eine Erweiterung der ursprünglichen transformer Architektur für Spracherkennung.</p>
<p>In 2019 bis Anfang der 2020er erreichten Transformer dann state of the Art Ergebisse.</p>
<h2 id="3-deep-learning-und-spracherkennung">3 Deep Learning und Spracherkennung</h2>
<p>Es gibt viele verschiedene Definitionen für Deep Learning, aber keine allgemein offiziell anerkannte Definition. Zwei Definitionen, welche die wesentlichen Punkte gut zusammenfassen sind Folgende:</p>
<div class="admonition info">
<p class="admonition-title">Definition von ibm</p>
<p>Deep Learning ist ein Teil des  maschinellen Lernens, bei dem es sich im Wesentlichen um ein neuronales Netz mit drei oder mehr Schichten handelt.</p>
</div>
<div class="admonition info">
<p class="admonition-title">Definition von oxford languages</p>
<p>A type of machine learning based on artificial neural networks in which multiple layers of processing are used to extract progressively higher level features from data.</p>
</div>
<p>Zusammengefasst ist Deep Learning ein Teil des maschinellen Lernens, bei dem man ein neuronales Netz mit mindestens 3 Schichten hat.</p>
<p>Deep Learning wurde in der Spracherkennung erst 2009 wirklich relevant, wurde aber schon früher für die Spracherkennung erforscht. Sowohl normale als auch deep Neuronal networks konnten nicht mit einem Hidden Markov Model mithalten, da es einige Probleme gab.</p>
<p>Ein Problem, war der diminishing gradient. Je weiter im Netz bei der Backpropagation zurück gerechnet wird,  um so kleiner wird der Gradient und "verschwindet" irgendwann. Das Problem hierbei ist, dass somit in den Schichten weiter hinten im Netz wenig bis keine Anpassungen mehr gemacht werden können und somit gewisse Datenzusammenhänge nicht erfasst werden können. Das tritt vor allem bei Aktivierungsfunktionen auf, die den Gradienten eher dämpfen. Ein gutes Beispiel dafür ist die Sigmoid Funktion. Ein weiteres Problem war die schwache zeitliche Korrelationsstruktur in neuronalen Netzen. Zudem fehlten damals noch große Trainingsdatensätze und Rechenleistung.</p>
<p>Als die Probleme nach und nach gelöst worden sind konnte durch Deep Learng große Fortschritte in der Spracherkennung erreicht werden. Die Ansätze sind mittlerweile so gut, dass diese mit mehreren menschlichen Transkriptoren mithalten können und sind heute State of the Art.</p>
<h2 id="4-speech-transformer-architektur">4 Speech Transformer Architektur</h2>
<p>In diesem Abschnitt wird die Speech Transformer Architektur aus dem Paper Speech-Transformer: A No-Recurrence Sequence-to-Sequence Model for Speech Recognition erklärt. Der Grund, warum genau diese Architektur genauer erklärt wird ist, dass es viele Abänderungen und Verbesserungen gibt die auf dieser Architektur aufbauen. Ziel ist es zu verstehen wie der Speech Transformer aufgebaut ist und funktioniert, um dann Abänderungen die darauf aufbauen leichter und schneller zu verstehen.</p>
<figure>
<p><img alt="Speechtransformer" src="../img/Spracherkennung/Speech_Transformer.png" width="400" />
  </p>
<figcaption>Fig. 5 Speechtransformer</figcaption>
</figure>
<p>Die Speechtransformer Architektur besteht aus zwei Teilen, einem Encoder und einem Decoder.</p>
<p>Der Encoder hat als Input ein Spektogramm. Am Anfang des Encoders sind drei Convolutional Layer mit einem 3x3 Kernel und Stride 2. Anschließend ist hier ein Block frei in dem optional zusätzliche Module eingefügt werden können. In dem Paper werden drei Beispiel genannt, wobei das interessanteste ein 2D Attention Mechanismus ist.</p>
<figure>
<p><img alt="2D Attention Mechanismus" src="../img/Spracherkennung/2d_att_module.png" width="400" />
  </p>
<figcaption>Fig. 6 2D Attention Mechanismus</figcaption>
</figure>
<p>Bei dem vorgeschlagenen Mechanismus werden zunächst drei convolutional networks auf den Input angewendet um daraus die Repräsentationen für Querries, Keys, und Values zu bekommen. Danach gibt es zwei Arten von Attention. Beides sind Scaled Dot-Product Attentions, jedoch ist die Erste für den zeitlichen Aspekt und die Zweite für den frequency Aspekt zuständig. Am Ende werden die ouputs zusammengefügt und in ein weiteres convolutional network gegeben.</p>
<p>Nach dem zusätzlichen optionalen Block wird eine linear Transformationen auf den flachgemachten feature map durchgeführt und mit dem positional encoding addiert. Positional Encoding ermöglicht dem Modell auf relative Positionen zu achten.</p>
<figure>
<p><img alt="Formel für das Berechnen des positional encoding" src="../img/Spracherkennung/positional_encoding.png" width="400" />
  </p>
<figcaption>Fig. 7 Formel für das Berechnen des positional encoding</figcaption>
</figure>
<p>Das Ergebnis der Summe durchläuft anschließend N Encoder Blöcke. Ein Encoder Block besteht aus einem Multi-Head-Attention Layer gefolgt von einem feedforward neuronal network. Zudem sind nach jedem Layer Layer Normalisationen eingebaut und es gibt residual connections.</p>
<p>Multi-Head-Attention besteht aus mehreren Scaled Dot-Products.</p>
<figure>
<p><img alt="Multi-Head-Attention" src="../img/Spracherkennung/Multi_Head_Attention.png" width="400" />
  </p>
<figcaption>Fig. 8 Multi-Head-Attention</figcaption>
</figure>
<p>Ein Scaled Dot-Product wird wie folgt berechnet:</p>
<figure>
<p><img alt="Scaled Dot-Product" src="../img/Spracherkennung/Scaled_Dot_Product.png" width="300" />
  </p>
<figcaption>Fig. 8 Scaled Dot-Product</figcaption>
</figure>
<p>Der Decoder hat die bisher generierte Ziel Sequenz als input. Als Erstes wird ein Zeichen Embedding angewandt um Wörter, Buchstaben oder Zeichen im Vektorraum darzustellen. Das Ergebnis wird zu einem positional encoding addiert, das genau wie bei dem Encoder berechnet wird. Das Ergebnis der Summe durläuft dann N Decoder Blöcke.</p>
<p>Ein Decoder Block besteht aus drei Teilen, einem masked Multi-Head-Attention Layer, einem Multi-Head-Attention Layer und einem feedforward neural network. nach jedem Layer gibt es wie beim Encoder auch Layer Normalsations und residual connections. Eine masked Multi-Head-Attention stellt sicher, dass die Vorhersagen für position j nur auf den outputs basiert die bis position j-1 gehen. Außerdem nimmt das Multi-Head-Attention Layer die Values und Keys von dem Output des Encoders, und die Querries aus dem eigenen Block.</p>
<p>Nach den Decoder Blöcken werden die outputs durch eine lineare Projektion und die anschließende Softmax Funktion in die Wahrscheinlichkeiten der Ausgangsklassen umgewandelt.</p>
<h2 id="5-anwendung">5 Anwendung</h2>
<h3 id="code-demo">Code-Demo</h3>
<h4 id="dataset">Dataset</h4>
<h5 id="data-ingestion">Data Ingestion</h5>
<p>In dieser Code-Demo werde ich über das Sammeln von Daten für Spracherkennung, Preprocessing und die Anwendung von zwei verschiedenen Models reden.
Der hier erwähnte Datensatz wird später nicht zum Training genutzt, sondern dient nur als Beispiel, da das Training zu "computationally expensive" war.</p>
<p>Am Anfang eines jeden Machine Learning Projekts steht das Sammeln von Daten.
Auch in dieser Code-Demo wird mit dem Sammeln von Daten begonnen. 
Die erste Phase hierfür ist die sogenannte Data Integration.
Diese Phase umfasst den Prozess des Sammelns und Importierens von Daten aus verschiedenen Quellen in ein System zur weiteren Verarbeitung oder Analyse.
In diesem Fall wurden mehrere verschiedene Datensätze aus dem Internet heruntergeladen.
Eine alternative wäre die Daten aus der realen Welt selbst zu machen, was allerdings für eine Privatperson sehr schwierig ist.</p>
<p>Hier werden zwei Beispiele der verwendeten Datensätze gezeigt:</p>
<p>Einerseits der Datensatz von Thorsten Müller, ein Datensatz der von einer Privatperson der Öffentlichkeit zur Verfügung gestellt wurde:</p>
<p><img alt="Datensatz von Thorsten Müller" src="../img/Spracherkennung/sc1.png" /></p>
<p>Und andererseits der sehr bekannte Common Voice Datensatz von Mozilla: </p>
<p><img alt="Datensatz von Mozilla Common Voice" src="../img/Spracherkennung/sc2.png" /></p>
<h5 id="data-transformation">Data Transformation</h5>
<p>Die nächste Phase ist die der Data Transformation.
Diese ist der Prozess der Umwandlung von Daten von einem Format oder einer Struktur in ein anderes, um die Datenanalyse zu erleichtern.</p>
<p>Die zuvor heruntergeladenen waren ursprünglich in vielen verschiedenen Formaten/Strukturen vorhanden:
* Ordnerstruktur + .csv
* Json
* .tsv / .csv</p>
<p>Diese verschiedenen Strukturen werden in diesem Schritt in ein einheitliches Format, in diesem Fall ein .csv-file pro Datensatz mit gleicher Struktur, gebracht</p>
<p>Nicht nur die Struktur, sondern auch die enthaltenen Informationen der Datensätze unterscheiden sich.
Die Hauptinformationen, die wirklich für das Training benötigt werden, sind jedoch immer vorhanden.
In diesem Fall sind das:
  * "sentence": Der Satz, der in der Audio-Datei gesprochen wird.
  * "path": Der Pfad zur Audio-Datei</p>
<p>Allerdings sind in diesen Datensätzen auch andere Informationen, die nicht direkt für das Training erforderlich sind enthalten.
  * Geschlecht
  * Akzent
  * Alter
  * Sprecher ID
  * source (original-Dataset)</p>
<p>Obwohl diese Daten weder für das Training notwendig, noch in allen Datensätzen vorhanden sind, sollten diese nicht "weggeworfen" werden, da diese für die Evaluation des Models, Identifikation von Fehlern, oder Analysierung des Aufbaus des Aufbaus des finalen Datensatzes sehr nützlich sein können.</p>
<p>Ausserdem wurde die Größe der Audio-Datei als Spalte hinzugefügt, um die Erstellung von Sub-datasets mit bestimmter Größe zu erleichtern.</p>
<h3 id="beispiel-der-umformung-eines-datensets">Beispiel der Umformung eines Datensets</h3>
<p>Hier wird als Beispiel der Code zur Umformung eines Datensatzes vorgeführt.</p>
<p>Die Import-Statements sind:
* pandas: Arbeit mit Datensätzen
* numpy: verschiedene optimierte numerische Operationen
* os/shutil: verschiedene Operationen mit Dateien
* tqdm: für Progressbars</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span>
</code></pre></div>
<p>Hier werden die Ordner definiert, in welche die transformierten Daten kommen:</p>
<div class="highlight"><pre><span></span><code><span class="n">clips_dest_dir</span> <span class="o">=</span> <span class="s2">&quot;../presentation_folders/new_dataset/clips/caito&quot;</span>
<span class="n">df_dest_dir</span> <span class="o">=</span> <span class="s2">&quot;../presentation_folders/new_dataset/dfs/caito&quot;</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">clips_dest_dir</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">clips_dest_dir</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">df_dest_dir</span><span class="p">):</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">df_dest_dir</span><span class="p">)</span>
</code></pre></div>
<p>Dies ist ein Screenshot, wie die Struktur dieses Datensatzes aussieht:</p>
<p><img alt="Datensatz von Mozilla Common Voice" src="../img/Spracherkennung/dir_structure.png" /></p>
<p>In diesem Code wird durch die Ordnerstruktur iteriert um die dort enthaltenen Informationen in ein .csv-file zu schreiben:</p>
<div class="highlight"><pre><span></span><code><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;speaker_id&quot;</span><span class="p">,</span> <span class="s2">&quot;path&quot;</span><span class="p">,</span> <span class="s2">&quot;sentence&quot;</span><span class="p">,</span><span class="s2">&quot;gender&quot;</span><span class="p">,</span><span class="s2">&quot;age&quot;</span><span class="p">,</span><span class="s2">&quot;accents&quot;</span><span class="p">])</span>

<span class="n">start_dir</span> <span class="o">=</span> <span class="s2">&quot;../presentation_folders/datasets/de_DE/by_book&quot;</span>

<span class="k">for</span> <span class="n">gender</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">start_dir</span><span class="p">):</span>
<span class="n">gender_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">start_dir</span><span class="p">,</span> <span class="n">gender</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">gender_dir</span><span class="p">):</span>
    <span class="k">continue</span>
<span class="k">for</span> <span class="n">speaker</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">gender_dir</span><span class="p">):</span>
    <span class="n">speaker_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gender_dir</span><span class="p">,</span> <span class="n">speaker</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">speaker_dir</span><span class="p">):</span>
        <span class="k">continue</span>
    <span class="k">for</span> <span class="n">recording_session</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">speaker_dir</span><span class="p">):</span>
        <span class="n">session_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">speaker_dir</span><span class="p">,</span> <span class="n">recording_session</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">session_dir</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">session_df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">session_dir</span><span class="p">,</span> <span class="s2">&quot;metadata.csv&quot;</span><span class="p">),</span><span class="n">sep</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">session_df</span><span class="o">=</span><span class="n">session_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s2">&quot;path&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="s2">&quot;raw_sentence&quot;</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="s2">&quot;sentence&quot;</span><span class="p">})</span>
        <span class="n">session_df</span><span class="o">=</span><span class="n">session_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;raw_sentence&quot;</span><span class="p">])</span>
        <span class="n">session_df</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">session_df</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.wav&quot;</span>

        <span class="n">session_df</span><span class="p">[</span><span class="s2">&quot;speaker_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">speaker</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">session_df</span><span class="p">))]</span>
        <span class="n">session_df</span><span class="p">[</span><span class="s2">&quot;gender&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">gender</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">session_df</span><span class="p">))]</span>
        <span class="n">session_df</span><span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">session_df</span><span class="p">))]</span>
        <span class="n">session_df</span><span class="p">[</span><span class="s2">&quot;accents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">session_df</span><span class="p">))]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span><span class="n">session_df</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gender: </span><span class="si">{</span><span class="n">gender</span><span class="si">}</span><span class="s2">, speaker: </span><span class="si">{</span><span class="n">speaker</span><span class="si">}</span><span class="s2">, recording session: </span><span class="si">{</span><span class="n">recording_session</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">session_df</span><span class="p">[</span><span class="s2">&quot;path&quot;</span><span class="p">][:</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">session_df</span><span class="p">)</span><span class="o">/</span><span class="mi">10</span><span class="p">)])):</span>
            <span class="n">src_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">session_dir</span><span class="p">,</span> <span class="s2">&quot;wavs&quot;</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">dest_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">clips_dest_dir</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">src_path</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">)</span>


<span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">df_dest_dir</span><span class="p">,</span> <span class="s2">&quot;caito.csv&quot;</span><span class="p">))</span>
</code></pre></div>
<h4 id="data-integration">Data Integration</h4>
<p>Der nächste Punkt ist die Data Integration. Hier werden die Daten in einen Datensatz zusammengefasst.
In diesem Fall ist dies sehr einfach, da wir einfach nur csv-files der selben Struktur zusammenfügen müssen.</p>
<p>Nun werden verschiedene Informationen über den fertigen Datensatz dargestellt und analysiert:
<div class="highlight"><pre><span></span><code><span class="n">df</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../complete_dataset/complete_size_df_woindex.csv&quot;</span><span class="p">)</span>
</code></pre></div></p>
<p>Hier wird die NaN-Ratio der verschiedenen Columns angegeben:
<div class="highlight"><pre><span></span><code><span class="n">df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NaN-Ratio</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">notna</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
</code></pre></div></p>
<p>Hier wird die Anzahl der verschiedenen Sprecher und Akzente gezeigt:
<div class="highlight"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;speaker_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;accents&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">())</span>
</code></pre></div></p>
<p>In diesem Code-Snippet wird die Verteilung des Geschlechts im Datensatz gezeigt:
<div class="highlight"><pre><span></span><code><span class="n">df</span><span class="p">[</span><span class="s2">&quot;gender&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</code></pre></div></p>
<h4 id="preprocessing">Preprocessing</h4>
<p>Um die Audio-Dateien in eine Form zu bringen die für Machine Learning Models verarbeitbar, gibt es viele verschiedene Preprocessing-Methoden. 
Hier werden zwei dieser Preprocessing-Methoden genauer angeschaut.
Die erste Methode die wir uns anschauen wollen, ist das Spektogram.
Dieses ist eine visuelle Darstellung des Spektrums des Signals über die Zeit.
In dieser Repräsentation gehen fast keine Daten verloren, was einerseits dazu führt, dass diese Methode sehr flexibel ist, wenn es darum geht für welchen Anwendungszweck sie verwendet werden kann, andererseits aber auch das Problem mit sich bringt, dass diese größere Menge von Daten im Vergleich zu anderen Methoden eine längere Trainingszeit mit sich zieht.</p>
<p>Hier kommt zum Beispiel MFCC ins Spiel. Diese Methode hat im Endeffekt eine viel kleinere Datenmenge und ist stark auf Spracherkennung spezialisiert. Ausserdem ahmt diese Methode das menschliche Gehör nach, wodurch diese Aspekte der Datenreduktion aber auch der Spezialisierung auf Spracherkennung entstehen.</p>
<p>Um diese Methoden in Python zu nutzen wird hier die library "librosa" verwendet.
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">librosa</span>
<span class="kn">import</span> <span class="nn">librosa.display</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</code></pre></div></p>
<p>Hier wird die zu verarbeitenden Audiodatei geladen.
<div class="highlight"><pre><span></span><code><span class="n">audio_file</span> <span class="o">=</span> <span class="s2">&quot;aufnahmen/english_audio.wav&quot;</span>
<span class="n">y</span><span class="p">,</span> <span class="n">sr</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">audio_file</span><span class="p">)</span>
</code></pre></div></p>
<p>In diesem Code-Snippet wird ein Spektogram der Audio-Datei geplottet.
<div class="highlight"><pre><span></span><code><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">amplitude_to_db</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">librosa</span><span class="o">.</span><span class="n">stft</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">ref</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">y_axis</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%+2.0f</span><span class="s1"> dB&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Spectrogram&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></p>
<p>In diesem Code-Snippet wird das MFCC der Audio-Datei gezeigt.
<div class="highlight"><pre><span></span><code><span class="n">mfccs</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">mfcc</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">n_mfcc</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">librosa</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">specshow</span><span class="p">(</span><span class="n">mfccs</span><span class="p">,</span> <span class="n">sr</span><span class="o">=</span><span class="n">sr</span><span class="p">,</span> <span class="n">x_axis</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;MFCC&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">mfccs</span>
</code></pre></div></p>
<h4 id="1model-gaussian-hmm">1.Model: Gaussian HMM</h4>
<p>Kommen wir nun zu den Modellen.
Das erste Modell über das wir sprechen werden ist GHMM.</p>
<p>Ein HMM ist ein statistisches Modell, das hilft, "unsichtbare" Zustände basierend auf beobachtbaren Daten zu schätzen. (z.B.: Wettervorhersage basierend auf menschlichem Verhalten, Textanalyse basierend auf Wortsequenzen etc.)</p>
<p>Ausserdem nutzt das GHMM die Gausssche Normalverteilung.</p>
<p>In dem folgenden Beispiel wird ein HMM auf ein Nummern-Dataset trainiert, da die ursprüngliche Idee, das deutsche Dataset in Wörter aufzuteilen, nicht umgesetzt werden konnte.
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">hmmlearn</span> <span class="kn">import</span> <span class="n">hmm</span>

<span class="kn">import</span> <span class="nn">librosa</span>
<span class="kn">from</span> <span class="nn">python_speech_features</span> <span class="kn">import</span> <span class="n">mfcc</span>
<span class="kn">import</span> <span class="nn">scipy.io.wavfile</span> <span class="k">as</span> <span class="nn">wav</span>
<span class="kn">import</span> <span class="nn">random</span> <span class="k">as</span> <span class="nn">rd</span>
</code></pre></div></p>
<p>Hier wird die Klasse HMMTrainer definiert, welche für das trainieren und auswerten der Daten verwantwortlich ist.
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">HMMTrainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">model_name</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">cov_type</span><span class="o">=</span><span class="s1">&#39;diag&#39;</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span> <span class="o">=</span> <span class="n">cov_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">GaussianHMM</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> 
                <span class="n">covariance_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_type</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
</code></pre></div>
In diesem Code-Snippet werden die Ordner der verschiedenen Nummern definiert:
<div class="highlight"><pre><span></span><code><span class="n">input_folder</span><span class="o">=</span><span class="s1">&#39;../models/HMM/digit_recordings&#39;</span>
<span class="n">word_folders</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">input_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)]</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">word_folders</span>
</code></pre></div></p>
<p>Hier werden die Audio-Dateien in MFCCs umgewandelt und für weitere Verarbeitung gespeichert:
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="n">lens</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">training_data</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">dirname</span> <span class="ow">in</span> <span class="n">word_folders</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ltt</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">subfolder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_folder</span><span class="p">,</span> <span class="n">dirname</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">subfolder</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.wav&#39;</span><span class="p">)][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subfolder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">sampling_freq</span><span class="p">,</span> <span class="n">audio</span> <span class="o">=</span> <span class="n">librosa</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>            
        <span class="n">mfcc_features</span> <span class="o">=</span> <span class="n">mfcc</span><span class="p">(</span><span class="n">sampling_freq</span><span class="p">,</span> <span class="n">audio</span><span class="p">)[:,:</span><span class="mi">13</span><span class="p">]</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mfcc_features</span><span class="p">)</span>

    <span class="n">training_data</span><span class="p">[</span><span class="n">dirname</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
</code></pre></div></p>
<p>So sehen die Daten aus:
<div class="highlight"><pre><span></span><code><span class="n">training_data</span><span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">]</span>
</code></pre></div></p>
<div class="highlight"><pre><span></span><code><span class="n">hmm_models</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">training_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">rd</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">label</span><span class="p">])</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">label</span><span class="p">][:</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;X.shape =&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">hmm_trainer</span> <span class="o">=</span> <span class="n">HMMTrainer</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="n">hmm_trainer</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="n">hmm_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hmm_trainer</span><span class="p">)</span>
    <span class="n">hmm_trainer</span> <span class="o">=</span> <span class="kc">None</span>
</code></pre></div>
<p>Training der Modelle (ein Model pro Wort):
<div class="highlight"><pre><span></span><code><span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">training_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
  <span class="n">d_results</span> <span class="o">=</span><span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">mfcc_features</span><span class="o">=</span><span class="n">training_data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="o">-</span><span class="n">i</span><span class="p">]</span>

    <span class="n">scores</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">hmm_models</span><span class="p">:</span>
        <span class="n">score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_score</span><span class="p">(</span><span class="n">mfcc_features</span><span class="p">)</span>
        <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
    <span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">label</span><span class="o">==</span><span class="p">(</span><span class="n">hmm_models</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">model_name</span><span class="p">))</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">d_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">label</span><span class="o">==</span><span class="p">(</span><span class="n">hmm_models</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">model_name</span><span class="p">))</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d_results</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">d_results</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">))</span>
</code></pre></div></p>
<h4 id="2model-wav2vec">2.Model: Wav2vec</h4>
<p>Das Wav2vec ist ein End-to-End-Model, das von Facebook AI 2019 entwickelt wurde und die Transformer-Architektur, die im vorherigen Teil schon erklärt wurde, nutzt. Es lernt also direkt aus Daten ohne eine manuelle Extraktion von Merkmalen aus der Audio (zB. via MFCC oder Spektogram zu benötigen). Es lernt sogar hauptsächlich aus unmakrkierten Rohdaten, was das ursprüngliche Trainieren, wenn man von der riesigen Datenmenge, die es benötigt, absieht, einfacher macht.
Es hat eine sehr gute Performance auf dem TIMIT-Datensatz, welcher normalerweise für Evaluationen von Speech-to-Text Systemen genutzt wird.</p>
<p><img alt="Datensatz von Thorsten Müller" src="../img/Spracherkennung/leaderboard.png" /></p>
<p>Zuerst müssen die entsprechenden libraries und der Tokenizer und das Model geladen werden.
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torchaudio</span>
<span class="kn">from</span> <span class="nn">transformers</span> <span class="kn">import</span> <span class="n">Wav2Vec2ForCTC</span><span class="p">,</span> <span class="n">Wav2Vec2Tokenizer</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">tokenizer</span> <span class="o">=</span> <span class="n">Wav2Vec2Tokenizer</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="s2">&quot;facebook/wav2vec2-base-960h&quot;</span><span class="p">)</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Wav2Vec2ForCTC</span><span class="o">.</span><span class="n">from_pretrained</span><span class="p">(</span><span class="s2">&quot;facebook/wav2vec2-base-960h&quot;</span><span class="p">)</span>
</code></pre></div></p>
<p>Hier wird eine im vorhinein aufgenommene Audiodatei geladen.
<div class="highlight"><pre><span></span><code><span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;aufnahmen/english_audio.wav&quot;</span>
<span class="n">speech</span><span class="p">,</span> <span class="n">rate</span> <span class="o">=</span> <span class="n">torchaudio</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</code></pre></div></p>
<p>Diese geladene Audidatei wird wird nun in das richtige Format gebracht.
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="n">speech</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">speech</span> <span class="o">=</span> <span class="n">speech</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">if</span> <span class="n">rate</span> <span class="o">!=</span> <span class="mi">16000</span><span class="p">:</span>
    <span class="n">resampler</span> <span class="o">=</span> <span class="n">torchaudio</span><span class="o">.</span><span class="n">transforms</span><span class="o">.</span><span class="n">Resample</span><span class="p">(</span><span class="n">orig_freq</span><span class="o">=</span><span class="n">rate</span><span class="p">,</span> <span class="n">new_freq</span><span class="o">=</span><span class="mi">16000</span><span class="p">)</span>
    <span class="n">speech</span> <span class="o">=</span> <span class="n">resampler</span><span class="p">(</span><span class="n">speech</span><span class="p">)</span>

<span class="n">speech</span> <span class="o">=</span> <span class="n">speech</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</code></pre></div></p>
<p>Zuletzt wird der Text dieses Audifiles predictet und ausgegeben.
<div class="highlight"><pre><span></span><code><span class="n">input_values</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="p">(</span><span class="n">speech</span><span class="p">,</span> <span class="n">return_tensors</span><span class="o">=</span><span class="s2">&quot;pt&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">input_values</span>

<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
    <span class="n">logits</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">input_values</span><span class="p">)</span><span class="o">.</span><span class="n">logits</span>

<span class="n">predicted_ids</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">transcription</span> <span class="o">=</span> <span class="n">tokenizer</span><span class="o">.</span><span class="n">batch_decode</span><span class="p">(</span><span class="n">predicted_ids</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">transcription</span><span class="p">)</span>
</code></pre></div></p>
<h2 id="6-weiterfuhrendes-material">6 Weiterführendes Material</h2>
<h3 id="podcast">Podcast</h3>
<p><a href="">Der Campus Talk – Silicon Forest – Folge XX</a></p>
<h3 id="podcast-transkript">Podcast Transkript</h3>
<p><strong>Moderator</strong>:
Hallo zusammen und willkommen zu einer neuen Ausgabe vom THD-Podcast, schön, dass Sie wieder eingeschaltet haben.
Jeder von uns hat doch bestimmt schon einmal Alexa, Siri oder den Google Assistant genutzt oder getestet. Doch haben Sie sich eigentlich mal Gedanken darüber gemacht, wie uns diese Geräte überhaupt verstehen?
Um diese und weitere Fragen zu klären, haben wir heute einen Experten zu Gast.</p>
<p>Herr Amuri studiert momentan Künstliche Intelligenz im sechsten Semester. Dort hat er bereits einige Aufgaben zur Spracherkennung lösen müssen und hat sich kürzlich auf diesen Themenbereich spezialisiert.</p>
<p>Herr Amuri, vielen Dank, dass Sie da sind.</p>
<p><strong>Experte</strong>:
Hallo, es freut mich sehr, dabei sein zu dürfen. </p>
<p><strong>Moderator</strong>:
Sagen Sie mir doch mal, wo kommt Spracherkennung überall vor?</p>
<p><strong>Experte</strong>:
Im Grunde, gibt es überall Spracherkennung, wo aus Gesprochenem für
eine Maschine lesbaren Text entsteht.
Bedeutet im Umkehrschluss, dass Spracherkennung vom sogenannten
“Speech-To-Text”, also gesprochenes Wort zu Text, bis hin zu einer Alexa reicht, die
das Wort “Alexa” selbst erkennen kann.</p>
<p><strong>Moderator</strong>: 
Ah verstehe! 
Also wenn Google Übersetzer mir einen Text vorliest, ist das keine Spracherkennung? Aber wenn ich was sage und es in Text umgewandelt wird, dann schon.</p>
<p>Dann ist aber meine Frage, wie funktioniert denn Spracherkennung bzw. wie wird das Gesprochene in Computersprache umgewandelt?</p>
<p><strong>Experte</strong>:
Ja, genau. Es verwechseln leider viele, dass die Definition von Spracherkennung an
sich leider keine Gleichung ist, wie man sie aus dem Matheunterricht kennt, sondern
als  Regel zu sehen ist.</p>
<p>Genau unterscheiden tun wir ja, wie die Sprache zustande kommt, beziehungsweise
meinen wir mit Spracherkennung auch wirklich die gesprochene Sprache. 
Der Prozess selbst beginnt deshalb auch mit der Aufnahme eines Sprachsignals,
beziehungsweise der gesprochenen Worte, wie diese Mikrofone hier vor uns es auch
tun.
Diese Aufnahmen werden dann in kleine Stücke aufgeteilt und anschließend nach
Faktoren wie die Tonhöhe, Frequenz und die Dauer der jeweiligen Töne analysiert.
Diese Merkmale werden dann anschließend in einem Sprachmodell verwendet, um
die Wörter und Sätze zu erkennen, die gesprochen wurden.
Das Ganze wird dann so oft wiederholt, bis es möglichst gut  erkannt
wird. Das kann man sich als Wahrscheinlichkeit vorstellen: Wenn wir eine Münze
werfen und unser Ziel “Kopf” ist, dann werfen wir immer wieder, bis endlich
Kopf oben liegt. 
Dabei gibt es  bestimmte Wurftechniken, wie wir “Kopf” erzwingen können.
Letztendlich erlernt das Sprachmodell selbstständig und teilweise mit 
Unterstützung diese Wurftechniken. Nach dem jetzigen Stand wird
es in keinem Fall immer das richtige Ergebnis haben, dafür aber sehr oft.</p>
<p><strong>Moderator</strong>:
Ah interessant. Das heißt also, dass Alexa selbst keine Spracherkennung ist, aber
wenn Alexa mich versteht und das verarbeitet, dann schon?</p>
<p><strong>Experte</strong>:
Genau.</p>
<p><strong>Moderator</strong>:
Verstehe.
Wir wussten ja natürlich, dass wir dich einladen und haben deshalb unsere Zuhörerschaft um Fragen für dich gebeten.
Die Erste passt sogar gut zum jetzigen Thema
lorelei8977, 24 Jahre alt fragt:
Sprachassistenten wie Alexa können uns ja auf unseren Wortlaut gehorchen. Nun ist meine Frage, hören uns Sprachassistenten immer zu?</p>
<p><strong>Experte</strong>:
Danke Lorelei für diese wirklich sehr interessante Frage.
Sprachassistenten hören uns generell per se nicht zu. Man kann es sich wie ein
kleines Baby vorstellen: Ein Baby versteht ja auch keine wirkliche Sprache bis
auf einzelne Schlüsselwörter, die es immer wieder hört. Sowas wie Spielplatz,
Milch oder auch seinen oder ihren Namen. So ähnlich ist es auch bei
Sprachassistenten.
Diese hören einem generell zu, jedoch verstehen sie einen nicht bzw. verstehen sie
nur spezifische Wörter, wie zum Beispiel bei Alexa das jeweilige Aktivierungswort.
Das bedeutet, an sich hören sie uns immer zu, da es anders leider nicht
funktionieren würde. Jedoch verstehen sie uns nicht, bis zu dem Zeitpunkt, wo wir
das Aktivierungswort sagen.</p>
<p>Im Falle Alexa ist auch wichtig anzumerken, dass die Hardware, also das Gerät, was
möglicherweise bei ihnen in der Wohnung steht, nur das Können besitzt, sein
Aktivierungswort zu erkennen.
Also wenn man zum Beispiel Alexa fragt: “Alexa, wie ist das Wetter”, fängt das
Gerät an, die Anfrage aufzunehmen. Das bedeutet, dass diese Aufnahme danach 
an Amazon gesendet wird.
Aus diesem Grund muss es immer mit dem Internet verbunden sein.
Die Aufnahme selbst gelangt an einen sicheren Ort innerhalb Amazon. 
Hier ist zu berücksichtigen, dass auch Amazon an Datenschutzrichtlinien gebunden
ist und Sicherheitsvorkehrungen besitzen.
Ob die Aufnahmen auch gespeichert werden dürfen, kann jeder in den
Alexa-Einstellung selbst entscheiden, standardmäßig ist das aktiviert.</p>
<p><strong>Moderator</strong>:
Oh, das ist sehr interessant. Also hören uns die kleinen Helferlein immer zu,
aber verstehen uns nicht, bevor wir Ihren Namen sagen. </p>
<p><strong>Experte</strong>:
Genau, hierzu ist aber auch anzumerken, dass es ohne diese Aufnahme gar nicht so
leicht wäre, alle Funktionen der Alexa in diesem kleinen Gerät zu lagern.
Die meisten Sprachassistenten funktionieren auf eine ähnliche Art und Weise und
deswegen ist das Aufnehmen der Stimme momentan nicht wegdenkbar.</p>
<p><strong>Moderator</strong>:
Alles klar, vielen Dank für die Anmerkung.
Ich würde dann direkt mit der nächsten Frage vom 
AktienKarl79 weitermachen, 44 Jahre alt:
“Wenn ich was per Spracherkennung bestelle, es aber etwas falsch erkennt und
damit falsch bestellt, wer ist dann Schuld?”</p>
<p><strong>Experte</strong>:
Also erstmal vorab, ich kann und darf keine rechtlichen Ratschläge geben, da
ich kein Experte in diesem Gebiet bin.
Generell ist die Frage aber anhand Alexa beantwortbar: Wenn ich nun
Alexa den Befehl gebe, mir einen Taschenrechner zu bestellen also “Alexa, bestelle
mir ein Taschenrechner”, wird sie mir den erstbesten Taschenrechner in den
Einkaufswagen legen, welcher dann meistens ein Amazon Choice Produkt
ist.
Anschließend wird sie mir den Produktnamen vorlesen, manchmal inklusive 
einer Kurzbeschreibung und mich am Ende des Satzes fragen, ob sie das Produkt
direkt kaufen soll.
Bedeutet, dass man normalerweise immer die Möglichkeit hat, die Bestellung zu
überprüfen, bevor sie tatsächlich abgeschlossen wird.
Also wird vermutlich die Schuld immer beim Kunden liegen.
Hier kann man aber beachten, dass es innerhalb der EU eine Widerrufsfrist von
mindestens 14 Tage für Online-Einkäufe gibt und man sich deshalb nicht viele
Gedanken machen muss.</p>
<p><strong>Moderator</strong>:
Ich wusste garnicht, dass Alexa auch für mich bestellen kann. Es ist aber sehr
gut zu wissen, dass mir so etwas nicht aus Versehen passieren kann.
Und hier gleich die nächste Frage:</p>
<p>KarlKloßbrühe, 16 Jahre alt fragt:
<em>“Lernt eine KI, die Spracherkennung benutzt, von dem was ich sage?”</em></p>
<p><strong>Experte</strong>:
Ah, das ist eine gute Frage.
Ja, Künstliche Intelligenz kann von uns lernen. 
Aber ob Sie das tut, wenn wir mit ihr sprechen, hängt von der Art der KI ab und wie
sie entwickelt wurde. Auch wie viel sie von uns tatsächlich lernt und wie schnell sie
das tut, ist logischerweise abhängig von der genauen Art der KI.</p>
<p>Wenn wir zum Beispiel mit einem Sprachassistenten wie Alexa sprechen, verwendet
dieser Techniken des maschinellen Lernens, um unsere Sprache besser zu
verstehen. Dabei kann die KI ihre Fähigkeiten zur Spracherkennung verbessern.
Hierbei ist es aber wichtig zu wissen, dass diese Art von Lernen meistens auf
Daten von ganz vielen verschiedenen Personen basieren und nicht nur auf einzelne
persönliche Daten.
Und wir sprechen hier nicht von ein paar 100 oder 200 Personen, sondern
meistens von mehreren Hunderttausenden.</p>
<p>Auf der anderen Seite gibt es jedoch auch KI-Systeme, die darauf ausgelegt sind,
sich an die Bedürfnisse und Vorlieben des einzelnen Benutzers anzupassen. 
In diesen Fällen lernt die KI tatsächlich direkt von Ihnen und kann Ihnen dadurch eine
bessere Benutzererfahrung bieten, siehe YouTube und TikTok</p>
<p>Kurz gesagt: KI-Systeme können von uns lernen, wenn wir sprechen. Aber wie viel
sie lernen und wie das die KI beeinflusst, ist von System zu System relativ
unterschiedlich.</p>
<p><strong>Moderator</strong>:
Vielen Dank für diese Erklärung! Ich hätte nicht gedacht, dass es bei
Spracherkennungssystemen so viele Unterschiede gibt.</p>
<p><strong>Experte</strong>:
Es ist in der Tat sehr spannend! Die Möglichkeiten, wie uns die KI helfen kann,
entwickeln sich ständig weiter. Ich freue mich schon darauf, wie sich
diese Technik im Verlauf der folgenden Jahre weiterentwickeln wird.</p>
<p><strong>Moderator</strong>:
Es bleibt auf jeden Fall spannend.
Dazu haben wir auch eine interessante Frage aus Twitter:
curiousmind27, 28 Jahre alt, fragt: "Wie hat sich Spracherkennung im Laufe der Zeit entwickelt und welche Veränderungen können wir in der Zukunft erwarten?"</p>
<p><strong>Experte</strong>:
Das ist eine schwere, aber durchaus spannende Frage.
Ich werde mal mein Bestes geben, die Frage grob zu beantworten. 
Sonst säßen wir morgen noch hier. </p>
<p>Zunächst gab es die einfacheren Systeme, die nur auf
bestimmte Befehle reagieren konnten und einen sehr begrenzten Wortschatz hatten.
Diese Systeme waren nicht sehr flexibel und konnten oft nicht mit verschiedenen
Sprech-Stilen, Akzenten oder Dialekten umgehen.</p>
<p>Dank der Fortschritte in künstlicher Intelligenz, maschinellem Lernen und der
Entwicklung neuronaler Netzwerke, sind wir nun in der Lage, Systeme zu entwickeln,
die eine weit größere Bandbreite an Sprachnuancen erkennen und verstehen
können.</p>
<p>Diese Systeme sind in der Lage, wie schon vorher erwähnt, aus riesigen Mengen an
Text- und Sprachdaten zu lernen. Was dann zu einer deutlichen Verbesserung der
Genauigkeit führt.</p>
<p>In der Zukunft können wir erwarten, dass Spracherkennungssysteme immer präziser
und menschenähnlicher werden. 
Sie werden besser darin sein, mit Akzenten, Dialekten und mehrsprachigen
Umgebungen umzugehen.
Zudem werden sie immer besser darin, den Kontext und die Absicht hinter
gesprochenen Wörtern zu verstehen. 
Das bedeutet, dass sie nicht nur die Wörter erkennen, sondern auch den Sinn und
die Bedeutung dahinter erfassen können.</p>
<p>Außerdem werden zukünftige Spracherkennungssysteme immer stärker in unseren
Alltag integriert sein. 
Wir können erwarten, dass sie in einer Vielzahl von Anwendungen eingesetzt
werden: Von persönlichen Assistenten, die uns bei alltäglichen Aufgaben
unterstützen, bis hin zu Systemen, die in der Arbeitswelt und im Bildungsbereich
eingesetzt werden. 
Eine weitere mögliche Entwicklung ist die Verbesserung der Emotionserkennung in
gesprochener Sprache, sodass Systeme besser auf unsere Stimmungen und
Gefühle eingehen können.</p>
<p><strong>Moderator</strong>:
Wow, da können wir uns ja auf einiges gefasst machen.</p>
<p><strong>Experte</strong>:
Absolut, die Technologie entwickelt sich ständig weiter und wir können sicherlich
noch viele spannende Entwicklungen im Bereich der Spracherkennung erwarten.</p>
<p><strong>Moderator</strong>:
Ah, hier ist eine weitere Frage, die gut zu der letzten anknüpft, von spargelgünther,
32 Jahre alt: "Können Sprachassistenten wie Alexa in der Lage sein, Emotionen in
der Stimme einer Person zu erkennen und darauf zu reagieren?"</p>
<p><strong>Experte</strong>:
Es gibt bereits Fortschritte in der Forschung und Entwicklung von
Technologien zur Emotionserkennung in der Sprache. 
Diese Technologien analysieren verschiedene Aspekte der menschlichen Stimme,
wie Tonhöhe, Lautstärke und Sprechgeschwindigkeit, um Emotionen wie Freude,
Traurigkeit, Wut oder Angst zu erkennen.</p>
<p>In Zukunft könnten Sprachassistenten wie Alexa diese Art von Emotionserkennung
nutzen, um besser auf die Bedürfnisse und Stimmungen der Benutzer eingehen zu
können. 
Zum Beispiel könnte ein Sprachassistent, der Traurigkeit in der Stimme eines
Benutzers erkennt, Empathie zeigen oder stimmungshebende Musik vorschlagen.
Es ist jedoch wichtig zu beachten, dass die Technologie noch verbessert werden
muss, bevor sie wirklich effektiv und allgemein verfügbar sein kann.</p>
<p><strong>Moderator</strong>:
Das klingt ja schon sehr menschlich.
Wie kann das dann weiter verwendet werden?
Ich meine, es muss ja auch sinnvollere Anwendungen geben, außer das vorschlagen
geeigneter Musik.</p>
<p><strong>Experte</strong>:
Ja klar, zusätzlich könnten zukünftige Sprachassistenten
auch dazu fähig sein, den Grad der Dringlichkeit bzw die Priorität einer Anfrage zu
erkennen. 
Das basiert dann auf der jeweiligen Stimmung und Betonung des Benutzers. 
Dadurch könnten sie noch besser auf die Bedürfnisse eingehen und je nachdem
maßgeschneiderte Antworten oder Aktionen vorschlagen.</p>
<p>Ein weiterer potenzieller Anwendungsbereich ist die Integration von
Emotionserkennung in Bereichen wie Kundendienst, Therapie oder Bildung. 
Durch das Verstehen der Emotionen des Benutzers könnten solche Systeme
personalisierte Lösungen anbieten und die Benutzererfahrung verbessern.</p>
<p>Es ist jedoch wichtig, ethische Fragen und den Datenschutz im Hinterkopf zu
behalten, wenn es um die Erkennung von Emotionen in der Sprache geht. 
Es wird entscheidend sein, transparente und verantwortungsbewusste Praktiken zu
entwickeln, um sicherzustellen, dass die Technologie zum Wohle der Benutzer
eingesetzt und ihre Privatsphäre respektiert wird.</p>
<p>Also lässt sich zusammenfassend sagen, dass Alexa, Siri etc. das im Moment zwar
nicht können, aber es vermutlich unsere Erfahrung mit Sprachassistenten  in der
Zukunft verändern wird.</p>
<p><strong>Moderator</strong>:
Das ist faszinierend! Es ist beeindruckend, wie weit die Technologie kommen könnte
und wie sie dazu beitragen kann, menschliche Erfahrungen besser zu verstehen und
darauf zu reagieren. 
Vielen Dank für Ihre Zeit und Ihr Wissen, Herr Amuri. </p>
<p><strong>Experte</strong>: 
Sehr gerne! Danke für die Einladung.</p>
<p><strong>Moderator</strong>: 
Wir freuen uns auf weitere spannende Themen in zukünftigen Folgen.</p>
<p>Ich war ihr Moderator und bedanke mich fürs Zuhören und schaltet doch auch
beim nächsten Mal wieder ein, wenn es heißt "Wie macht denn Technik?". Tschüss.
<em>Ende</em></p>
<h3 id="talk">Talk</h3>
<p>Hier einfach Youtube oder THD System embedden.</p>
<h3 id="demo">Demo</h3>
<p>Link zur Code Demonstration:</p>
<p>Link zum Repository: <a href="https://mygit.th-deg.de/sh28544/spracherkennung_codedemo">https://mygit.th-deg.de/sh28544/spracherkennung_codedemo</a></p>
<h2 id="7-literaturliste">7 Literaturliste</h2>
<p><a href="https://www.ibm.com/topics/speech-recognition">ibm: What is speech recognition</a></p>
<p><a href="https://www.pcworld.com/article/477914/speech_recognition_through_the_decades_how_we_ended_up_with_siri.html">PCWorld: Speech Recognition Through the Decades: How We Ended Up With Siri</a></p>
<p><a href="https://summalinguae.com/language-technology/speech-recognition-software-history-future/">summalinguae: Speech Recognition Software: Past, Present, and Future</a></p>
<p><a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=bdcf7f42bc5db1842250b4dc3e5911a181dbd685">Wiqas Ghai, Navdeep Singh (2012) Literature Review on Automatic Speech Recognition</a></p>
<p><a href="https://www.itbusiness.ca/news/history-of-voice-recognition-from-audrey-to-siri/15008">itbusiness: History of voice recognition: from Audrey to Siri</a></p>
<p><a href="https://sonix.ai/history-of-speech-recognition">sonix: A short history of speech recognition</a></p>
<p><a href="https://en.wikipedia.org/wiki/Speech_recognition">wikipedia: Speech recognition</a></p>
<p><a href="https://en.wikipedia.org/wiki/Timeline_of_speech_and_voice_recognition">wikipedia: Timeline of speech and voice recognition</a></p>
<p><a href="https://web.ece.ucsb.edu/Faculty/Rabiner/ece259/Reprints/354_LALI-ASRHistory-final-10-8.pdf">B.H. Juang, Lawrence R. Rabiner (2004)Automatic Speech Recognition – A Brief History of the Technology Development</a></p>
<p><a href="https://www.ibm.com/ibm/history/exhibits/specialprod1/specialprod1_7.html">ibm: Shoebox</a></p>
<p><a href="https://ee.stanford.edu/~gray/lpcip.pdf">Robert M. Gray (2010) Linear Predictive Coding and the Internet Protocol A survey of LPC and a History of of Realtime Digital Speech on Packet Networks</a></p>
<p><a href="https://stacks.stanford.edu/file/druid:rq916rn6924/rq916rn6924.pdf">Bruce T. Lowerre (1976) The HARPY Speech Recognition System</a></p>
<p><a href="https://pubs.aip.org/asa/jasa/article-abstract/62/6/1345/744517/Review-of-the-ARPA-Speech-Understanding-Project?redirectedFrom=fulltext">Dennis H. Klatt (1977) Review of the ARPA Speech Understanding Project</a></p>
<p><a href="https://www.ri.cmu.edu/pub_files/pub2/lee_k_f_1990_1/lee_k_f_1990_1.pdf">Kai-Fu Lee, Hsiao-Wuen Hon, Raj Reddy (1990) An Overview of the SPHINX Speech recognition system</a></p>
<p><a href="https://web.stanford.edu/~jurafsky/slp3/A.pdf">Speech and Language Processing. Daniel Jurafsky &amp; James H. Martin</a></p>
<p><a href="https://stanford.edu/class/ee365/lectures/markov.pdf">Markov Chains</a></p>
<p><a href="https://arxiv.org/pdf/1001.2267.pdf">M.A.Anusuya, S.K.Katti (2009) Speech Recognition by Machine: A Review</a></p>
<p><a href="https://static.googleusercontent.com/media/research.google.com/de//pubs/archive/38131.pdf">Geoffrey Hinton, Li Deng, Dong Yu, George Dahl, Abdel-rahman Mohamed, Navdeep Jaitly, Andrew Senior, Vincent Vanhoucke, Patrick Nguyen, Tara Sainath, and Brian Kingsbury (2012) Deep Neural Networks for Acoustic Modeling in Speech Recognition</a></p>
<p><a href="http://proceedings.mlr.press/v32/graves14.pdf">Alex Graves, Navdeep Jaitly Towards End-to-End Speech Recognition with Recurrent Neural Networks</a></p>
<p><a href="https://arxiv.org/pdf/1508.01211.pdf">William Chan, Navdeep Jaitly, Quoc V. Le, Oriol Vinyals (2015) Listen, Attend and Spell</a></p>
<p><a href="https://www.microsoft.com/en-us/research/blog/microsoft-researchers-achieve-new-conversational-speech-recognition-milestone/">Xuedong Huang (2017) Microsoft researchers achieve new conversational speech recognition milestone</a></p>
<p><a href="https://en.wikipedia.org/wiki/Speakable_items">wikipedia: Speakable items</a></p>
<p><a href="https://en.wikipedia.org/wiki/CMU_Sphinx">wikipedia: CMU Sphinx</a></p>
<p><a href="https://www.techradar.com/news/the-evolution-of-speech-recognition-technology">Graeme John Cole (2021) The evolution of speech recognition technology</a></p>
<p><a href="https://jonathan-hui.medium.com/speech-recognition-gmm-hmm-8bb5eff8b196">Jonathan Hui (2019) Speech Recognition — GMM, HMM</a></p>
<p><a href="https://www.ibm.com/ibm/history/ibm100/us/en/icons/speechreco/">ibm: Pioneering Speech Recognition</a></p>
<p><a href="https://www.ibm.com/de-de/topics/deep-learning">ibm: Was ist Deep Learning?</a></p>
<p>[<a href="https://www.cs.toronto.edu/~hinton/absps/DNN-2012-proof.pdf">Geoffrey Hinton, Li Deng, Dong Yu, George Dahl, Abdel-rahman Mohamed, Navdeep Jaitly, Andrew Senior, Vincent Vanhoucke, Patrick Nguyen, Tara Sainath, Brian Kingsbury (2012) Deep Neural Networks for Acoustic Modeling in Speech Recognition</a></p>
<p><a href="https://www.researchgate.net/publication/3457621_Advances_in_speech_transcription_at_IBM_under_the_DARPA_EARS_program">Stanley Chen, Brian Kingsbury, Lidia Mangu,Daniel Povey, George Saon, Hagen Soltau and Geoffrey ZweigIBM T. J. Watson Research Center, Yorktown Heights (2006) Advances in Speech Transcription at IBM under theDARPA EARS Program</a></p>
<p><a href="https://www.sciencedirect.com/topics/engineering/template-matching">X. Binjie, HuJ. (2008) Template Matching</a></p>
<p><a href="https://towardsdatascience.com/intuitively-understanding-connectionist-temporal-classification-3797e43a86c">Harald Scheidl (2018) An Intuitive Explanation of Connectionist Temporal Classification</a></p>
<p><a href="https://en.wikipedia.org/wiki/Hidden_Markov_model">wikipedia: Hidden Markov model</a></p>
<p><a href="https://ieeexplore.ieee.org/document/8462506">Linhao Dong, Shuang Xu, Bo Xu (2018) Speech-Transformer: A No-Recurrence Sequence-to-Sequence Model for Speech Recognition</a></p>
<p><a href="https://arxiv.org/pdf/1706.03762.pdf">Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, Illia Polosukhin (2017) Attention is all you need</a></p>
<p><a href="https://www.sciencedirect.com/topics/mathematics/hidden-markov-models">Oliver C. Ibe (2013) Markov Processes for Stochastic Modeling</a></p>
<p><a href="https://study.com/academy/lesson/speech-recognition-history-fundamentals.html">Speech Recognition: History &amp; Fundamentals</a></p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.expand", "navigation.indexes"], "search": "../../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.220ee61c.min.js"></script>
      
        
          <script src="../../javascripts/katex.js"></script>
        
      
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
        
      
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
        
      
    
  </body>
</html>